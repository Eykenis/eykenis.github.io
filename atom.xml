<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ekke の Space</title>
  <icon>https://www.gravatar.com/avatar/b74e4d6380810c10e04719b2f9079a61</icon>
  
  <link href="https://eykenis.github.io/atom.xml" rel="self"/>
  
  <link href="https://eykenis.github.io/"/>
  <updated>2023-12-12T09:38:04.288Z</updated>
  <id>https://eykenis.github.io/</id>
  
  <author>
    <name>Ekennis</name>
    <email>ekennis@outlook.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Games104 总结</title>
    <link href="https://eykenis.github.io/2023/09/15/Games104/"/>
    <id>https://eykenis.github.io/2023/09/15/Games104/</id>
    <published>2023-09-15T08:39:26.000Z</published>
    <updated>2023-12-12T09:38:04.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="02-引擎架构分层"><a href="#02-引擎架构分层" class="headerlink" title="02 引擎架构分层"></a>02 引擎架构分层</h1><p>引擎架构包含以下几层：</p><ul><li>工具层</li><li>功能层</li><li>资源层</li><li>核心层</li><li>平台层</li></ul><h2 id="工具层"><a href="#工具层" class="headerlink" title="工具层"></a>工具层</h2><p>工具层是面向引擎使用者的。它提供一系列接口，以让引擎使用者可以使用该引擎上手制作游戏。通常包括地图编辑、材质编辑等。</p><h2 id="功能层"><a href="#功能层" class="headerlink" title="功能层"></a>功能层</h2><p>功能层负责实现游戏的核心玩法。为了模拟游戏场景中的行为，现代游戏引擎一般都使用 “<strong>tick</strong>“ 这一概念。每经过一个小时刻就执行一次循环。也就是说，游戏世界的时间是不连续的，离散的。</p><p>每一个 tick 中我们通常需要做两件事：</p><ol><li>帧逻辑。一般就是这一帧的模拟。在 3D 引擎中包括物理计算等。也包括玩家的输入输出，数据计量等。</li><li>帧渲染。逻辑计算完后，该帧所有资源的渲染信息都确定了，于是需要将图像渲染到屏幕上。</li></ol><h2 id="资源层"><a href="#资源层" class="headerlink" title="资源层"></a>资源层</h2><p>资源层的重要任务之一：将资源导入引擎。</p><p>将数据引擎化类似于将 word 变为 txt 的过程——我们只保留可编辑部分，对其他文件格式导致的附加内容进行裁剪。</p><p>资源层的重要任务之二：资源的关系组织。</p><p>这一点类似于文件系统。一个完整的资产通常包含材质、mesh、贴图、shader 等多个属性。为了让这几个资产组织起来，需要另外一个 composed asset. composed asset 本身也是资产之一，是引擎的 reference 特性的体现。为了为每个资产一个唯一标识，我们还需要引入<strong>GUID</strong>.</p><p>UI 层面上，我们还需要一个资源管理器。这也与 Windows 的文件管理器类似。</p><p>而在资源层之外，游戏执行的核心之一即管理资产们的生命周期。</p><h2 id="核心层"><a href="#核心层" class="headerlink" title="核心层"></a>核心层</h2><p>核心层通常写一些支持其它层调用的底层接口。</p><p>包括线性代数库、数据结构等。</p><p>为什么需要自己的一套数据结构？以 C++ 的 std 为例，vector 的空间分配为段式，在性能要求非常高的游戏开发中可能会导致许多不必要的内存分配。</p><p>一个很好的轮子：<a href="https://github.com/electronicarts/EASTL">electronicarts/EASTL</a>，EA 为解决 C++ 引擎开发中的性能问题而诞生。</p><p>还比如一些对象池之类的功能。把内存管理好，把性能提优，都属于核心层的使命。</p><h2 id="平台层"><a href="#平台层" class="headerlink" title="平台层"></a>平台层</h2><p>这一层主要是为了跨平台而存在。虽然不是完全必要，但一个只能在单平台使用的现代引擎未免太不合格。</p><p>而不同的平台，对不同的图形 API 兼容又各不相同。因此我们需要一层 RHI，将这些硬件 SDK 封装起来。</p><p>除此以外也有很多其他的兼容问题……</p><p>（当然对个人 toy 引擎来说，支持跨平台确实有点过于复杂）</p><h1 id="03-构建"><a href="#03-构建" class="headerlink" title="03 构建"></a>03 构建</h1><h2 id="ECS-架构"><a href="#ECS-架构" class="headerlink" title="ECS 架构"></a>ECS 架构</h2><p>使用 Composed-based Tick 要优于 Object-based Tick. 以 pipeline 的形式更适合数据整合批处理。</p><h3 id="interactions-实现"><a href="#interactions-实现" class="headerlink" title="interactions 实现"></a>interactions 实现</h3><p>Hardcore：GO 间通信，GO 互相调用、生成。这一方法也可以在 Scripts 中写出，</p><p>更优秀的方法包括<strong>射线检测</strong>，<strong>Events系统</strong>。</p><h3 id="interactions-优化：四-八叉树"><a href="#interactions-优化：四-八叉树" class="headerlink" title="interactions 优化：四/八叉树"></a>interactions 优化：四/八叉树</h3><h3 id="BVH-层次包围盒"><a href="#BVH-层次包围盒" class="headerlink" title="BVH 层次包围盒"></a>BVH 层次包围盒</h3><h3 id="引擎-demo-功能"><a href="#引擎-demo-功能" class="headerlink" title="引擎 demo 功能"></a>引擎 demo 功能</h3><h1 id="04-渲染（1）"><a href="#04-渲染（1）" class="headerlink" title="04 渲染（1）"></a>04 渲染（1）</h1><h3 id="光栅化-pipeline"><a href="#光栅化-pipeline" class="headerlink" title="光栅化 pipeline"></a>光栅化 pipeline</h3><p>略</p><h3 id="纹理采样"><a href="#纹理采样" class="headerlink" title="纹理采样"></a>纹理采样</h3><p>在有 mipmap 支持时，一种能达到比较好的 sample 方案是：采取最近的两级 mipmap，分别进行双线性插值采样，结果再线性插值合成。</p><h3 id="Mesh"><a href="#Mesh" class="headerlink" title="Mesh"></a>Mesh</h3><p>一个 mesh 必须包含：</p><ul><li>vertex data</li><li>index data</li><li>face (triangle/octangle) data</li></ul><p>Optional 的：</p><ul><li>normal data</li><li>uv data</li><li>color data</li><li>…</li></ul><p>相应地，引擎需要为 mesh 的应用，在内存中提供 buffers，例如 vertex buffers、index buffers……</p><p>为了方便 Mesh 的树级管理，各个部件应用不同的 material，引擎一般都有 Submesh 的概念。不同的 submesh 使用 mesh 的不同组顶点。</p><h3 id="Materials"><a href="#Materials" class="headerlink" title="Materials"></a>Materials</h3><p>决定 shading 效果的组件。</p><p>一个 material 必须包含：</p><ul><li>shader</li></ul><p>可以包含：</p><ul><li>texture (PBR)<ul><li>albedo</li><li>normal</li><li>metallic</li><li>roughness</li><li>AO</li></ul></li></ul><h3 id="Resource-Pool"><a href="#Resource-Pool" class="headerlink" title="Resource Pool"></a>Resource Pool</h3><p>通过索引提高资源重用率。而为了重用并且保证不同组件被识别为不同，引擎通常都有 instance 的概念。通过资源索引创建一个 instance。</p><h3 id="视锥裁剪"><a href="#视锥裁剪" class="headerlink" title="视锥裁剪"></a>视锥裁剪</h3><p>除了普通渲染器提供的齐次裁剪以外，会渲染更多 object 的 game engine 需要更多样化的裁剪来确保性能，例如 <strong>GPU culling</strong></p><h3 id="纹理压缩"><a href="#纹理压缩" class="headerlink" title="纹理压缩"></a>纹理压缩</h3><p>DXTC</p><p>ETC/PVRTC</p><h2 id="新技术：Cluster-Based-Mesh-Pipeline"><a href="#新技术：Cluster-Based-Mesh-Pipeline" class="headerlink" title="新技术：Cluster-Based Mesh Pipeline"></a>新技术：Cluster-Based Mesh Pipeline</h2><p>由显卡支持，可以用一个算法，基于数据生成几何。</p><p>一个有名的 further work: Nanite</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;02-引擎架构分层&quot;&gt;&lt;a href=&quot;#02-引擎架构分层&quot; class=&quot;headerlink&quot; title=&quot;02 引擎架构分层&quot;&gt;&lt;/a&gt;02 引擎架构分层&lt;/h1&gt;&lt;p&gt;引擎架构包含以下几层：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工具层&lt;/li&gt;
&lt;li&gt;功能层&lt;</summary>
      
    
    
    
    
    <category term="Games" scheme="https://eykenis.github.io/tags/Games/"/>
    
  </entry>
  
  <entry>
    <title>程序员编曲学习指南</title>
    <link href="https://eykenis.github.io/2023/08/27/Arranger-Tutorial-For-Programmers/"/>
    <id>https://eykenis.github.io/2023/08/27/Arranger-Tutorial-For-Programmers/</id>
    <published>2023-08-27T15:55:36.000Z</published>
    <updated>2023-12-12T09:36:38.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>因为最近玩的音乐游戏《Arcaea》里各种好听的纯音乐以及曲师 Laur、Sakuzyo 等人的经历，我也对学习计算机编曲产生了一些不知道是否是三分钟热度的兴趣。但是既然想学那就开始吧，也不要求自己能达到多高的水准。</p><p>（我最喜欢的是像 Pentiment, Fracture Ray, Heavensdoor 这样富有节奏的谱，也喜欢 Aegleseeker、Ether Strike 这种 lead 很猛的歌）</p><p>由于看了一些乐理知识的视频后，发现自己没有像学习 CS 知识一样整理 MD 笔记而非常不习惯，因此打算开这一栏目，并以教程的风格将自己学习时的知识点归纳下来，<del>以更适合程序员</del>。取名 neta 自仓库《程序员做饭指南》。</p><h1 id="乐理相关"><a href="#乐理相关" class="headerlink" title="乐理相关"></a>乐理相关</h1><h2 id="简谱"><a href="#简谱" class="headerlink" title="简谱"></a>简谱</h2><h2 id="钢琴键"><a href="#钢琴键" class="headerlink" title="钢琴键"></a>钢琴键</h2><h3 id="钢琴键格式"><a href="#钢琴键格式" class="headerlink" title="钢琴键格式"></a>钢琴键格式</h3><p>在钢琴键上可以观察到如下的循环节：</p><p>白-黑-白-黑-白-白-黑-白-黑-白-黑-白</p><p>一共 7 个白键、5个黑键。其中前两个黑键和后三个黑键相距两个白键，其余间隔都是一个白键。</p><p>而钢琴一共有 7 个这样的循环节。</p><p>外加钢琴的前 3 个不在循环节中的键：白-黑-白，以及最后一个多出来的白键，钢琴一共有 <strong>88</strong> 个键，其中 <strong>52</strong> 白键，<strong>36</strong> 黑键。</p><h3 id="钢琴音调"><a href="#钢琴音调" class="headerlink" title="钢琴音调"></a>钢琴音调</h3><p>钢琴键的循环节一共 7 个白键。它们分别对应该音高下的 Do-Re-Mi-Fa-So-La-Ti.</p><p>在钢琴键中，一般将 Do~Ti 写作 C D E F G A B.</p><p>而黑键则对应 5 个半调。</p><p>半调的写法有两种，一种是加 #，表示升半调；一种是加 b，表示降半调。例如，C 调与 D 调中间的黑键既可以写作 #C，也可以写作 bD.</p><h2 id="五线谱"><a href="#五线谱" class="headerlink" title="五线谱"></a>五线谱</h2><p>如图：</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230828183309971.png" alt="image-20230828183309971"></p><h3 id="线"><a href="#线" class="headerlink" title="线"></a>线</h3><p>如上图，五条线从下到上依次是第一线~第五线。但除开这五条线在谱面会直接画出外，五线谱也存在其它平时省略掉的线，例如上加一线、上加二线、下加一线等。如果需要在这些部分添加音符，则需要加一个短横在音符上以表明其所在的线。</p><h3 id="间"><a href="#间" class="headerlink" title="间"></a>间</h3><p>间即两线之间的部分。自下往上分别称为第一间~第四间。</p><h3 id="记号"><a href="#记号" class="headerlink" title="记号"></a>记号</h3><p>五线谱的开头通常是一个高音谱号或低音谱号，用于作为后面出现音调的基准。下面分别是高音符号和低音符号的示例图片。</p><p>高音：</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/treble-clef.svg" alt="treble-clef" style="zoom:33%;" /></p><p>低音：</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/Bass-key.svg" alt="Bass-key" style="zoom:33%;" /></p><p>其中，高音谱号以穿过螺旋线中心的线作为 G4 音调，低音谱号以两点所夹线为 F2 音调。</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/P5`%T[O9VX$[NUPPI~1HB34.png" alt="img"></p><h2 id="音程"><a href="#音程" class="headerlink" title="音程"></a>音程</h2><p>我们简单来说就是键盘上两个键之间的距离，单位是度。</p><p>为了通过音程一个信息区分出更多的键位位置信息，音程采用 “属性+数字” 的方式命名。</p><h2 id="和弦"><a href="#和弦" class="headerlink" title="和弦"></a>和弦</h2><p>三个以上音构成和弦。</p><p>通常，和弦是以某一个音作为根音，以某个度为公差的等差数列构成的。和弦中最高的音称为冠音。</p><p>在演奏时，和弦的各个音同时播放。</p><p>例如，三和弦有三个音，每两个音的音程为 3 度；七和弦有四个音，每两个音的音程为 7 度。</p><h3 id="和弦分类"><a href="#和弦分类" class="headerlink" title="和弦分类"></a>和弦分类</h3><p>以三和弦为例：</p><p>大三和弦：大 3 度 + 小 3 度</p><p>小三和弦：小 3 度 + 大 3 度</p><p>增三和弦：大 3 度 + 大 3 度</p><p>减三和弦：小 3 度 + 小 3 度</p><p>以此类推，七和弦包括大大七和弦、小小七和弦、大小七和弦、减小七和弦和减减七和弦。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;p&gt;因为最近玩的音乐游戏《Arcaea》里各种好听的纯音乐以及曲师 Laur、Sakuzyo 等人的经历，我也对学习计算机编曲产生了一些不知道是</summary>
      
    
    
    
    <category term="其他" scheme="https://eykenis.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>NoPe-NeRF： Optimising Neural Radiance Field with No Pose Prior</title>
    <link href="https://eykenis.github.io/2023/08/15/NoPe-NeRF-Reading/"/>
    <id>https://eykenis.github.io/2023/08/15/NoPe-NeRF-Reading/</id>
    <published>2023-08-15T11:51:16.000Z</published>
    <updated>2023-08-15T14:31:35.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>训练一个没有预先计算相机姿态的神经辐射场（NeRF）是具有挑战性的。最近在这个方向上的进展展示了在前向场景中联合优化NeRF和相机姿态的可能性。然而，这些方法在摄像机有剧烈移动时仍然面临困难。为了解决这个具有挑战性的问题，我们引入了无畸变单目深度先验。这些先验是通过在训练过程中校正尺度和平移参数生成的，然后我们可以用它们来约束相邻帧之间的相对姿态。这个约束是通过我们提出的新型损失函数来实现的。对于真实世界室内和室外场景的实验表明，我们的方法可以处理具有挑战性的相机轨迹，并在新视角渲染质量和姿态估计准确性方面优于现有方法。我们的项目页面是<a href="https://nope-nerf.active.vision./">https://nope-nerf.active.vision。</a></p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>略</p><h2 id="2-相关工作"><a href="#2-相关工作" class="headerlink" title="2 相关工作"></a>2 相关工作</h2><h3 id="2-1-新视角合成"><a href="#2-1-新视角合成" class="headerlink" title="2.1 新视角合成"></a>2.1 新视角合成</h3><p>早期新视角合成使用像素之间的插值。后来则通常使用 3D 重建渲染图像。最近最流行的场景表示方法则为 NeRF. 而相关的 NeRF 及其优化应用方法都需要使用 SfM 预训练来获得训练集的相机位姿。</p><h3 id="2-2-位姿优化-NeRF"><a href="#2-2-位姿优化-NeRF" class="headerlink" title="2.2 位姿优化 NeRF"></a>2.2 位姿优化 NeRF</h3><p>近期的一个研究热点为简化或消除相机位姿参数的预处理这一步骤。一类方法使用 SLAM 风格。另一类方法直接优化相机姿态与 NeRF 模型 (unposed-NeRF).</p><p>iNeRF 的研究表明可以使用重建的 NeRF 模型估计图像姿态。GNeRF 将生成对抗网络和 NeRF 结合以估计相机姿态，但需要已知姿态采样分布。</p><p>NeRFmm 提出同时优化相机的内参和外参。BARF 提出了一种位置编码策略来联合优化相机姿态与 NeRF. SC-NeRF 进一步参数化相机的失真，采用几何损失对射线进行规范化。GARF 表明使用高斯-MLP 使得联合姿态和场景优化更加容易和准确。SiNeRF 使用 SIREN 层和一种新采样策略来缓解 NeRFmm 中的联合优化次优性问题。虽然在像 LLFF 这样的前向数据集上显示了好结果，但在处理具有大相机运动和复杂相机轨迹时仍然面临困难。我们通过将mono-depth 图与相机参数和 NeRF 联合优化紧密结合来解决问题。</p><h4 id="注解：先前工作对位姿同时优化的研究："><a href="#注解：先前工作对位姿同时优化的研究：" class="headerlink" title="注解：先前工作对位姿同时优化的研究："></a><strong>注解：先前工作对位姿同时优化的研究</strong>：</h4><p><strong>1. 最简单的同时优化想法：用 BP 同时优化位姿，但容易陷入次优解</strong></p><p><strong>2. 位置编码虽然可以加速重建，但也容易导致次优解</strong></p><p><strong>3. BARF提出使用经典图像对齐同时优化位姿和模型</strong></p><p><strong>NeRFmm提出通过光度损失同时优化位姿和模型</strong></p><h4 id="关于几何-辐射模糊性"><a href="#关于几何-辐射模糊性" class="headerlink" title="关于几何-辐射模糊性"></a>关于几何-辐射模糊性</h4><p>NeRF++ 提出来了这一点。NeRF 本身高频输入坐标+相对低频后输入位姿可以很好地避免几何-辐射模糊性。</p><h2 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h2><p>本文将解决：在无位姿信息的 NeRF 训练中处理大相机运动的挑战。</p><p>给定图像、相机内参和单目深度估计，可以同时恢复相机姿态并优化 NeRF. 假设相机内参在图像元信息中可用，可以运行 DPT 获取单目深度估计。</p><p>训练过程中，我们对相机姿态和每个单目深度图的畸变参数进行联合优化。畸变参数通过最小化单目深度图与从 NeRF 渲染的深度图之间的差异来进行监督，后者是多视图一致的。反过来，无畸变的深度图有效缓解了形状-辐射二义性，简化了 NeRF 和相机姿态的训练。</p><p>具体而言，无畸变的深度图实现了两个约束。通过相邻图像之间的相对姿态来限制全局姿态估计。通过从无畸变深度图反投影的两个点云间的倒角距离来实现。此外还通过将无畸变深度视为表面，使用基于表面的光度一致性对相对姿态估计规范化。</p><h3 id="3-1-NeRF"><a href="#3-1-NeRF" class="headerlink" title="3.1 NeRF"></a>3.1 NeRF</h3><p>NeRF 将场景表示为映射神经网络（具体见 NeRF 论文）。给定 $N$ 张图片 $I_1,…,I_n$ 和相应位姿 $\pi_1,…,\pi_n$，这个 NeRF 网络可以通过最小化光度误差作为 loss 来优化（$L_{rgb}=\sum_i^N||I_i-\hat I_i||_2^2$）.</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230801200338319.png" alt="image-20230801200338319"></p><p>其中 $ L_{rgb} = \sum_i^N ||Ii − \hat Ii||_2^2$，$\hat I$ 是</p><p>（复述 NeRF）</p><h3 id="3-2-对位姿和-NeRF-的联合优化"><a href="#3-2-对位姿和-NeRF-的联合优化" class="headerlink" title="3.2 对位姿和 NeRF 的联合优化"></a>3.2 对位姿和 NeRF 的联合优化</h3><p>先前有研究表明有可能通过在体积渲染过程中最小化光度误差来同时估计相机参数和 NeRF。</p><p>关键在于将相机的光线投射化为相机参数 $\Pi$。此时相机射线 $r$ 作为相机位姿的函数。数学上这种联合优化可以表示为：<br><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230801200320677.png" alt="image-20230801200320677"></p><p>相机参数 $\Pi$ 包括相机内参、姿态和镜头畸变等。但在 Nope-NeRF 中，我们只考虑相机姿态。例如帧 $L_i$ 的姿态是一个变换 $T_i=[R_i|t_i]$（齐次坐标下旋转矩阵和位移向量的增广阵）</p><h3 id="3-3-单目深度估计去畸变"><a href="#3-3-单目深度估计去畸变" class="headerlink" title="3.3 单目深度估计去畸变"></a>3.3 单目深度估计去畸变</h3><p>使用现成的 DPT 做单目深度，可以从输入图像生成单目深度图序列 $D=\{D_i|i=0,…,N-1\}$. 单目深度图并不与多视图一致，因此我们的目标是恢复一系列多视图一致的深度图。</p><p>具体来说，对每一个单目深度图，考虑两个线性变换参数，得到所有帧的变换参数序列 $\alpha_i,\beta_i$，分别表示缩放因子和位移因子。通过 NeRF 的多视图一致性约束，可以恢复 $D_i$ 的多视图一致深度图。</p><script type="math/tex; mode=display">D_i^*=\alpha_iD_i+\beta_i</script><p>通过同时优化 $\alpha_i$，$\beta_i$ 以及 NeRF 模型来进行联合优化。这种联合优化主要通过无畸变深度图 $D_i^*$ 和 NeRF 渲染的深度图 $\hat D_i$ 之间的一致性来实现。深度损失函数如下：</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230801211504006.png" alt="image-20230801211504006"></p><p>其中</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230801211512822.png" alt="image-20230801211512822"></p><p>表示 NeRF 经过体渲染得到的深度图。</p><p>注意 NeRF 和单目深度图都通过公式（5）优化. 单目深度为 NeRF 提供了几何先验，减少了形状-辐射二义性。另一方面，NeRF 提供了多视图一致性，因此可以恢复一组多视图一致的深度图用于姿态估计。</p><h3 id="3-4-相对姿态约束"><a href="#3-4-相对姿态约束" class="headerlink" title="3.4 相对姿态约束"></a>3.4 相对姿态约束</h3><p>先前的工作独立优化每个相机姿态，导致对错误姿态的图像进行过拟合。对帧间不正确的相对姿态进行惩罚可以规范联合优化，使得在复杂的相机轨迹下平滑收敛。因此我们提出两个约束相对姿态的损失函数。</p><ol><li>点云</li></ol><p>用相机内参数将无畸变深度图 $D^<em>$ 反投影为点云 $P^</em>$，通过最消化点云损失来优化相对姿态：</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230801213009103.png" alt="image-20230801213009103"></p><p>其中 $T_{ji}=T_jT_i^{-1}$，表示从点云 $P_i^<em>$ 通过 $T$ 变换到的估计点云 $P_j^</em>$ ，</p><p>$l_{cd}$ 表示倒角距离。</p><ol><li>表面光度损失</li></ol><p>$L_{pc}$ 在 3D-3D 匹配方面进行了监督，但给予表面的广度误差可以减轻不正确的匹配。在光度一致性假设下，该光度惩罚相关像素外观的差异。</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230801221731992.png" alt="image-20230801221731992"></p><p>其中乘法为取样操作。$K_i$ 是第 $i$ 个相机的投影矩阵。</p><h3 id="3-5-完整的训练-pipeline"><a href="#3-5-完整的训练-pipeline" class="headerlink" title="3.5 完整的训练 pipeline"></a>3.5 完整的训练 pipeline</h3><p>我们的整个 loss 可以表示为：</p><script type="math/tex; mode=display">\mathcal{L}={\mathcal{L}}_{rgb}+\lambda_1 {\mathcal{L}}_{depth}+\lambda_2 \mathcal{L}_{pc}+\lambda_3 {\mathcal{L}_{rgb-s}}</script><p>$\lambda_i$ 为超参数，权重。</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230801221929220.png" alt="image-20230801221929220"></p><p>最后返回 NeRF 的参数 $\Theta$，相机位姿 $\Pi$ 和畸变参数 $\Psi$.</p><h3 id="4-实验"><a href="#4-实验" class="headerlink" title="4. 实验"></a>4. 实验</h3><h3 id="4-1-本文实验方法"><a href="#4-1-本文实验方法" class="headerlink" title="4.1 本文实验方法"></a>4.1 本文实验方法</h3><p><strong>数据集</strong>：Tanks and Temples 和 ScanNet.</p><p>Tanks Temples 包含 8 个场景用于评估姿态和新视角合成质量。图像下采样到 960x540，对 family 场景采样 200 张图像，奇数帧用于训练集，偶数帧用于新视角合成测试。</p><p>ScanNet 中，我们采用 4 个场景用于评估姿态准确性、深度准确性和新视角合成质量。对每个场景使用 80-100 个连续图像，使用其中 1/8 用于新视角合成。评估使用 ScanNet 提供的深度图和姿态作为 ground truth. 所有 ScanNet 图都下采样到 648x484，预处理时裁剪带有黑边的图像。</p><p><strong>评估指标</strong>：对新视角合成，使用峰值信噪比（PSNR）、结构相似性指数（SSIM）和学习感知图像块相似性（LPIPS）；对姿态评估，使用标准视觉里程计指标，包括绝对轨迹误差和相对姿态误差。使用 ATE 衡量估计的相机位置与 groundtruth 之间的差异。使用 RPE 衡量成对图像之间的相对姿态误差，包括相对旋转误差（RPEr）和相对平移误差（RPETA）。使用标准的深度估计指标。遵循 Zhou 等人的方法匹配渲染深度图和 ground truth 深度图的中值。</p><p><strong>details</strong>：</p><ol><li>修改了 NeRF 结构，用 Softplus 替换 ReLU 激活函数。意义不明，但可能实验结果更好，总之没有说原因。</li><li>预定义范围 (0.1, 10) 内在每条射线上均匀采样 128 个点。使用 2 个单独的 Adam 优化器优化 NeRF 和其它参数。NeRF 初始学习率 0.001，姿态和畸变初始学习率 0.0005…</li></ol><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>代码地址：</p><p><a href="https://github.com/ActiveVisionLab/nope-nerf">GitHub - ActiveVisionLab/nope-nerf: (CVPR 2023) NoPe-NeRF: Optimising Neural Radiance Field with No Pose Prior</a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li><p>单目深度估计的畸变，会出现非线性畸变吗？</p><p>这方面好像没有做实验，只是提了一嘴，目前我也并不知道单目深度估计除了尺度与偏移的畸变还有哪些原因会导致其他不同性质的畸变。</p></li><li><p>2-stage 是怎么做的？</p><p>NoPe-NeRF 的方法与 COLMAP 的两步法不一致，是联合优化模型与位姿的。但文中为了对比其与传统 NeRF 的性能，将 NoPe-NeRF 网络改为 2-staged，即先单独估计位姿，再训练出模型，这与联合优化是完全相悖的，这种 2-stage 方法非常奇怪，作者也没有给出具体的网络方法，莫名其妙。</p></li><li><p>大相机运动？</p><p>文中并没有直接给出能证明大相机运动优于其他 NeRF 方法的实验结果，却直接把 “能处理大相机运动” 作为 NoPe-NeRF 的创新点之一，有点怪异。相邻帧约束的优化会让人直觉上认可这一点，可惜文中并没有给出实验证据。（深度学习怎么解释都说得通，但真得 Show 一 Show 实验数据）</p><p>而且和学长讨论时还有一个问题，NoPe-NeRF 似乎并不能处理无序输入序列，看来 NoPe-NeRF 对数据的要求仍然不低。</p></li></ol><p>综上，个人觉得除了在低纹理下有明显优点以外，其余在实验中显示相比 NeRF 并无明显提升。其中提及最多的 “能处理大相机运动” 为什么完全没有实验佐证？</p>]]></content>
    
    
    <summary type="html">读论文</summary>
    
    
    
    <category term="问道" scheme="https://eykenis.github.io/categories/%E9%97%AE%E9%81%93/"/>
    
    
    <category term="ML" scheme="https://eykenis.github.io/tags/ML/"/>
    
    <category term="CV" scheme="https://eykenis.github.io/tags/CV/"/>
    
  </entry>
  
  <entry>
    <title>NeRF：Representing Scenes as Neural Radiance Fields for View Synthesis 阅读与复现</title>
    <link href="https://eykenis.github.io/2023/07/31/NeRF-translation/"/>
    <id>https://eykenis.github.io/2023/07/31/NeRF-translation/</id>
    <published>2023-07-31T15:50:53.000Z</published>
    <updated>2023-08-03T06:26:48.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Part-1-翻译"><a href="#Part-1-翻译" class="headerlink" title="Part. 1 翻译"></a>Part. 1 翻译</h2><p>*使用带位姿信息的神经辐射场表示场景</p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>NeRF 使用一个全连接的深度网络表示场景，输入为连续的 5D 坐标，输出为该位置的体积密度和<strong>视角相关的</strong>辐射强度。</p><p>NeRF 方法通过查询射线的 5D 坐标合成视角，使用经典的<strong>体积渲染技术</strong>输出颜色和密度，投影到图像中。体积渲染可导，通过这一点可以优化表示，使得只需要使用一组有已知相机姿态的图像作为输入。</p><p>本文还探讨了如何继续优化神经辐射场来渲染具有复杂几何外形的场景，与前人工作进行了比较。</p><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h3><p>给定一组输入图像及相应的相机姿态生成场景新视角。</p><p>要正确输出逼真的场景，必须正确处理复杂的<strong>几何形状</strong>和<strong>材质反射特性</strong>。</p><p>现在我们需要一个能在大范围相机基线上实现逼真质量场景还原的方法。</p><p>（总之，我们提出了一种高质量且高性能的神经渲染方法）</p><p>实现：将静态场景输入表示为一个 5D 函数 $(x,y,z,\theta,\phi)$，输出为（1）每个点上的密度 $\rho$，密度充当不透明度，表示光线穿过 $(x,y,z)$ 积累的辐射强度、（2）视角相关的 RGB 颜色。通过优化一个深度全连接神经网络来<strong>不使用卷积</strong>去表示模型。</p><p>推理步骤：</p><ol><li>沿相机射线生成一系列 3D 采样点。</li><li>使用对应的 2D 观察方向作为输入，生成一组输出颜色和密度。</li><li>使用体积渲染技术将输出积累到 2D 图像中，可以使用梯度下降法优化。</li></ol><p>即这一过程中需要先使用一个多层全连接神经网络输出三维点的密度和颜色，再使用体积渲染还原为 2D 图像。</p><p>问题1：</p><p>该表示无法收敛到足够高的分辨率。需要使用 5D 坐标进行<strong>位置编码</strong>。</p><p>问题2：</p><p>使用体素/网格方法，存储成本非常大。需要使用神经网络的参数来存储场景信息。</p><h3 id="2-相关工作"><a href="#2-相关工作" class="headerlink" title="2. 相关工作"></a>2. 相关工作</h3><p>近期（2019~2020）三维重建中的一个研究热点是将物体和场景编码到 MLP 的权重中来隐式表达 3D 空间位置映射。但是这种方法难以准确精细。</p><p>NeRF 增强了神经场景表示的能力，以产生渲染复杂逼真场景的最先进结果。</p><h3 id="2-1-神经-3D-形状表示"><a href="#2-1-神经-3D-形状表示" class="headerlink" title="2.1 神经 3D 形状表示"></a>2.1 神经 3D 形状表示</h3><p>近期许多研究将$(x,y,z)$ 映射到有符号距离函数或占据场的深度网络。但是这些模型受限于对真实 3D 几何形状的要求（Occupancy Networks 的强分类关联），使得数据集通常需要从诸如 ShapeNet 之类的 baseline 中获取。之后的研究通过构建可微分渲染函数来放宽对真实 3D 形状的要求，使得神经隐式形状表示可以使用 2D 图像进行优化。Niemeyer 等人将表面表示为占据场，并使用数值方法找到每条射线的表面交点，然后使用隐式微分计算精确导数。每个射线交点位置作为输入提供给一个神经 3D 纹理场，该场预测该点的漫反射颜色。Sitzmann 等人使用一个不那么直接的神经 3D 表示方法，简单地在每个连续的 3D 坐标处输出一个特征向量和 RGB 颜色，提出了一个由递归神经网络组成的可微分渲染函数，该函数沿着每条射线前进以确定表面的位置。</p><p>这些研究可能足够用于表示复杂高分辨率几何形状，但仍然限制在简单几何形状上，导致复杂结果渲染过于平滑。</p><p>我们的解决方法是通过优化网络来编码 5D 辐射场。可以表示更高分辨率、更复杂的的几何形状。</p><h3 id="2-2-视角合成和基于图像渲染"><a href="#2-2-视角合成和基于图像渲染" class="headerlink" title="2.2 视角合成和基于图像渲染"></a>2.2 视角合成和基于图像渲染</h3><p>使用基于网格的场景表示，可微光栅化器和可微路径追踪器可以直接优化网格表示，通过梯度下降重现一组输入图像。但基于图像投影的基于梯度的网格优化通常很困难，可能是由于局部最小值或损失函数表面的糟糕条件。而且这种方法通常固定拓扑结构，难以对于无约束真实场景通用。</p><p>另一种方法使用体积表示来解决问题。体积表示法能够逼真表示复杂形状材质，非常适合基于梯度优化，并且产生更少的伪影。早起体积方法观察图像后直接为体素网格上色。近期的方法使用大量包含多个场景的数据集来训练深度网络，从一组输入图像预测采样的体积表示，然后在测试时使用 alpha 合成或沿射线学习来渲染新视角。</p><p>还有一些工作将 CNN 和体素网格结合优化，使得 CNN 可以弥补来自低分辨率体素网格的离散化伪影，允许预测体素网格根据输入时间或动画控制而变化。但这些研究在扩展到更高分辨率图像方面的能力还是受到离散采样的制约——时间和空间复杂度非常高。</p><p>我们通过深度全连接神经网络中参数编码连续体积来绕过这个问题，产生了比以往体积方法更高质量的渲染结果，而存储成本只有体积表示的一小部分。</p><h3 id="3-神经辐射场的场景表示"><a href="#3-神经辐射场的场景表示" class="headerlink" title="3. 神经辐射场的场景表示"></a>3. 神经辐射场的场景表示</h3><p>输入为 5D 向量函数 $(x,y,z,\theta,\phi)$，输出为 $c\sigma$（$(r,g,b)$ 和体积密度 $\sigma$）。在实践中，我们将方向表示为 3D 笛卡尔单位向量 $d$,使用 MLP 网络表示如下函数：</p><script type="math/tex; mode=display">F_\theta:(x,d)\rarr(c,\sigma)</script><p>近似这个连续的 5D 场景表示，并优化权重 $\theta$，使得每个输入能映射到相应体积密度和方向发射的颜色。</p><p>为了让网络能在多视角下尽量保持一致性，我们限制网络将体积密度 $\sigma$ 预测仅为与 $(x,y,z)$ 有关的函数，然后让位置和视角 $(\theta,\phi)$ 去共同决定颜色输出 $c$. 为了实现这一点，$F_\theta$ 首先使用 8 个全连接层，每层使用 ReLU 激活 + 256通道）处理输入的三维坐标，并输出 $\sigma$ 和一个 256 维的特征向量。然后将特征向量与相机射线的视角方向进行拼接，传递给一个额外的全连接层（ReLU 激活，128 通道），输出视角相关的 RGB 颜色。</p><p> 我们可以用输入的视角方向来表现一些不符合兰伯特定律的图形。</p><h3 id="4-辐射场体渲染"><a href="#4-辐射场体渲染" class="headerlink" title="4. 辐射场体渲染"></a>4. 辐射场体渲染</h3><p>5D 神经辐射场将场景表示为空间中各个点的体密度和方向辐射强度。使用经典体积渲染原理来渲染穿过场景的任意射线的颜色。</p><p>体积密度 $\sigma(x)$ 可以被解释为射线在位置 $x$ 处终止于无穷小粒子的微分概率。相机射线 $r(t)=o+t_d$ 的期望颜色 $c(r)$（其中 $o$ 是相机位置，$d$ 是射线方向，$t$ 是参数化射线的参数，近截和远截参数分别为 $t_n$, $t_f$，颜色的计算公式如下：</p>$$C({\bold r})=\int_{t_n}^{t_f}T(t)\sigma({\bold r}(t))c({\bold r}(t),{\bold d}){\rm d}t$$<p>，其中  $T(t)=\exp{(-\int_{t_n}^t\sigma(\bold r(s)){\rm d}s)}$. </p><p>函数 $T(t)$ 表示 $t_n$ 到 $t$ 的累积透射率，即射线在 $t_n$ 到 $t$ 的路径上没有与其他粒子碰撞的概率。从我们的连续神经辐射场渲染视图，对通过所需虚拟相机的每个像素跟踪的相机射线估计积分 $C(r)$. 使用数值积分方法（蒙特卡洛积分）来对这个连续积分进行估计。确定性积分方法通常用于渲染离散化的体素网格，但使用体素方法会极大限制分辨率。作为替代，我们使用分层抽样，将 $[t_n,t_f]$ 划分为 $N$ 个均匀间隔区间，然后在每个区间内均匀抽取一个样本。</p>$$t_i\sim u\begin{bmatrix}t_n+{{i-1}\over N}(t_f-t_n),t_n+{i\over N}(t_f-t_n)\end{bmatrix}.$$<p>这样，尽管我们使用的是离散样本集，但分层抽样使得我们能够表示连续场景，这是因为在优化过程中，MLP 会在连续的位置进行评估（为什么呢）。我们使用这些样本，使用 Max 等人在体积渲染综述中提出的求积法则来估计 $C(r)$.</p><script type="math/tex; mode=display">\hat C({\bold r})=\sum_{i=1}^NT_i(1-\exp(-\sigma_i\delta_i))c_i</script><script type="math/tex; mode=display">T_i=\exp(-\sum_{j=1}^{i-1}\sigma_j\delta_j)</script><p>，其中 $\delta_i=t_{i+1}-t_i$，为分层取样点的间距。</p><p>使用 $c_i,\sigma_i$ 来计算 $\hat C(\bold r)$ 是可微的，并且可以简化为传统 alpha 合成，其中$\sigma_i=1-\exp(-\sigma_i\delta_i)$.</p><h3 id="5-优化神经辐射场"><a href="#5-优化神经辐射场" class="headerlink" title="5. 优化神经辐射场"></a>5. 优化神经辐射场</h3><p>为了实现高分辨率复杂场景的表示，我们需要两个改进措施。</p><p>（1）对输入坐标进行位置编码，帮助 MLP 表示高频率函数。</p><p>（2）使用层次体积抽样。</p><h4 id="5-1-位置编码"><a href="#5-1-位置编码" class="headerlink" title="5.1 位置编码"></a>5.1 位置编码</h4><h4 id="5-2-层次抽样"><a href="#5-2-层次抽样" class="headerlink" title="5.2 层次抽样"></a>5.2 层次抽样</h4><h3 id="6-结果"><a href="#6-结果" class="headerlink" title="6. 结果"></a>6. 结果</h3><h2 id="Part-2-问题"><a href="#Part-2-问题" class="headerlink" title="Part. 2 问题"></a>Part. 2 问题</h2><h3 id="摘要-1"><a href="#摘要-1" class="headerlink" title="摘要"></a>摘要</h3><ol><li><p>什么是体积渲染技术？</p><p> 体积渲染即神经渲染，相较于原来的光栅化/光线追踪，使用神经网络进行逆向渲染.</p></li></ol><h3 id="辐射场体渲染"><a href="#辐射场体渲染" class="headerlink" title="辐射场体渲染"></a>辐射场体渲染</h3><ol><li><p>公式 $(3)$ 中的 $u$ 是什么？</p><p> $u$ 指代<strong>均匀分布</strong>。</p></li><li><p>MLP 连续评估的原理？</p></li><li><p>文中所指的 alpha 合成是什么？好像并不是前景合成透明图片？</p></li></ol><h2 id="Part-3-理解分析"><a href="#Part-3-理解分析" class="headerlink" title="Part. 3 理解分析"></a>Part. 3 理解分析</h2><p>NeRF 使用的重要概念之一，神经辐射场，其数据形式即 $(c,\sigma)$，使用如下模型隐式表达：</p><script type="math/tex; mode=display">F_\theta:(x,y,z,\theta,\phi)\rarr(c,\sigma)</script><p>然后看公式 $(2)$，</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230730222823497.png" alt="image-20230730222823497"></p><p>其中 $T(t)$ 通俗点讲就是 $t$ 之前没有碰到粒子的概率，$\sigma(t)$ 表示 $t$ <strong>处</strong>碰到粒子的概率。</p><p>$T(t)=\exp{(-\int_{t_n}^t\sigma(\bold r(s)){\rm d}s)}$，$r(t)=o+t_d$.</p><p>再看公式 $(3)$. 因为实际用计算机计算时还是只能使用离散采样，因此我们要选择一个采样方法，$(3)$ 即 NeRF 采用的方法。这个很好理解，就是$[t_n,t_f]$ 的 $N$ 个均匀离散点。</p><p>然后得到 $C(r)$ 的离散近似估计，即公式$(4)$.</p><p>这里把 $T(t)$ 换成离散的 $T_i$，$\int\sigma({\bold r}(t)){\rm d}t$ 换成 $\sum\exp(-\sigma_i\delta_i)$, $c(r(t),d)$ 换成 $c_i$（该离散点期望的颜色）。</p><p>然后是两个对求 $C(r)$ 的优化。</p><p>MLP 倾向于学习低频信息，导致渲染表示颜色和几何图形的高频变化方面表现得比较差。作者还表明，在将输入传递到网络之前，高频函数可以将输入映射到更高维空间，更好你和包含高频变化的数据。</p><p>因此，优化之一是转而使用位置编码，令 $F_\theta=F_\theta’·\Gamma$. 其中 $\Gamma$ 为位置信息。</p><p><strong>可以参考一下 Transformer 模型的编码方式.</strong></p><p>二是分层采样。沿着每个相机光线在 $N$ 个查询点密集评估辐射场网络效率很低：自由空间和已经被遮挡的区域都被采样了。使用分层采样可以缓解这一问题。即一开始使用粗采样，然后计算预期颜色。</p><h2 id="Part-4-复现"><a href="#Part-4-复现" class="headerlink" title="Part. 4 复现"></a>Part. 4 复现</h2><p>用 autodl 跑示例代码。</p>]]></content>
    
    
    <summary type="html">了解了解</summary>
    
    
    
    <category term="问道" scheme="https://eykenis.github.io/categories/%E9%97%AE%E9%81%93/"/>
    
    
    <category term="ML" scheme="https://eykenis.github.io/tags/ML/"/>
    
    <category term="CV" scheme="https://eykenis.github.io/tags/CV/"/>
    
  </entry>
  
  <entry>
    <title>机器学习中的 Embedding 和 Encoding</title>
    <link href="https://eykenis.github.io/2023/07/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84-Embedding-%E5%92%8C-Encoding/"/>
    <id>https://eykenis.github.io/2023/07/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84-Embedding-%E5%92%8C-Encoding/</id>
    <published>2023-07-31T02:33:39.000Z</published>
    <updated>2023-07-31T03:17:29.584Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Embedding"><a href="#Embedding" class="headerlink" title="Embedding"></a>Embedding</h1><p>Embedding layer 即嵌入层。</p><p>具体来说，就是实现两类不同特征的映射。这种映射满足线性空间中的<strong>同构</strong>。</p><p>同构：A、B满足双射，且双射运算 $\sigma$ 满足</p><script type="math/tex; mode=display">\sigma(a,b)=\sigma(a)+\sigma(b)\\\sigma(ka)=k\sigma(b)</script><p>即加法和数乘封闭。</p><p>Embedding 的实现方法就是对原来的特征向量组进行矩阵乘法来实现降维得到新的特征向量组。</p><h2 id="为什么要使用-Embedding"><a href="#为什么要使用-Embedding" class="headerlink" title="为什么要使用 Embedding"></a>为什么要使用 Embedding</h2><p>传统的特征编码有两种方法。</p><p>一是直接编码：将原特征直接类似哈希的方法表示成数字。</p><p>二是 one-hot. 这种方法适于稀疏矩阵运算。</p><p>这两种方案都存在表示后数据过大的问题。</p><p>Embedding 层的解决办法则是通过矩阵降维来解决数据过大的问题。</p><p>当然，Embedding 层也能用于升维。升维的作用是放大某些特征，分开一些 general 的特征，形成一个良好的观测点。</p><h1 id="Encoding"><a href="#Encoding" class="headerlink" title="Encoding"></a>Encoding</h1><p>就是编码的过程。</p><p>将我们输入的初始信息编码成特征向量的网络即 encoder.</p><p>相应地，decoder 做的就是将特征向量还原为可直接应用的信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Embedding&quot;&gt;&lt;a href=&quot;#Embedding&quot; class=&quot;headerlink&quot; title=&quot;Embedding&quot;&gt;&lt;/a&gt;Embedding&lt;/h1&gt;&lt;p&gt;Embedding layer 即嵌入层。&lt;/p&gt;
&lt;p&gt;具体来说，就是实现两类不同</summary>
      
    
    
    
    <category term="问道" scheme="https://eykenis.github.io/categories/%E9%97%AE%E9%81%93/"/>
    
    
    <category term="ML" scheme="https://eykenis.github.io/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>FFT Ocean 推导与实现</title>
    <link href="https://eykenis.github.io/2023/05/29/FFTOcean/"/>
    <id>https://eykenis.github.io/2023/05/29/FFTOcean/</id>
    <published>2023-05-29T15:20:10.000Z</published>
    <updated>2023-06-24T11:06:37.994Z</updated>
    
    <content type="html"><![CDATA[<p>预计实现在自己自行编写的软渲染器 KERenderer 上。</p><p>因为 Hexo 对 $LaTeX$ 的支持不够好，因此公式没法完整发过来。</p><p>流程推导见：</p><p><a href="https://zhuanlan.zhihu.com/p/633200862">https://zhuanlan.zhihu.com/p/633200862</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;预计实现在自己自行编写的软渲染器 KERenderer 上。&lt;/p&gt;
&lt;p&gt;因为 Hexo 对 $LaTeX$ 的支持不够好，因此公式没法完整发过来。&lt;/p&gt;
&lt;p&gt;流程推导见：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/63</summary>
      
    
    
    
    <category term="问道" scheme="https://eykenis.github.io/categories/%E9%97%AE%E9%81%93/"/>
    
    
    <category term="FFT" scheme="https://eykenis.github.io/tags/FFT/"/>
    
    <category term="渲染" scheme="https://eykenis.github.io/tags/%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>你做的前十个游戏都是垃圾，所以赶紧做掉吧。</title>
    <link href="https://eykenis.github.io/2023/05/24/First10/"/>
    <id>https://eykenis.github.io/2023/05/24/First10/</id>
    <published>2023-05-24T03:03:35.000Z</published>
    <updated>2023-05-28T09:07:59.138Z</updated>
    
    <content type="html"><![CDATA[<p><strong>《游戏设计艺术》里有这样一句话：“ 你做的前十个游戏都是垃圾，所以赶紧做掉吧。”</strong></p><p>我相信这句话，重点在于 “赶紧做掉”。我们刚开始写的游戏基本上都是烂货，没有仔细去打磨的必要，而更应该赶紧将新的知识应用到新的 demo 里，去创造一个越来越完善越来越优秀的系统。</p><p>既然如此，我来统计，回顾一下我曾尝试过的 demo，并进行相应的反思总结，督促自己继续学习，做新的内容。从大一入学开始算。</p><p><del>首先，学 c++ 基础时写的五子棋、走迷宫、扫雷等不算。</del></p><h2 id="2021年3月-5月-骑兵与猎人"><a href="#2021年3月-5月-骑兵与猎人" class="headerlink" title="2021年3月~5月 骑兵与猎人"></a>2021年3月~5月 骑兵与猎人</h2><p>这段时间学了一点 Unity 基本用法，后来因为要刷算法竞赛搁置了。很惭愧，直到现在（2023.5）我的 Unity 基础仍然是一团糟。</p><p>同人作品，故事的主题是方舟第一个 Sidestory 的复现。其中涉及到的 Unity 知识主要包括用 Tilemap 刷地图，帧动画和人物状态机等。没有用混合树，当时觉得太麻烦了。</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230524112741260.png" alt="image-20230524112741260"></p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230524112813395.png" alt="image-20230524112813395"></p><p>第一次尝试有点想一口吃成胖子的味道。完全没有学过任何策划知识的情况下写了一些随意想出的策划案，最后基本没有实现，只是做了人物移动和攻击动画（笑</p><h2 id="2022-1-2022-2-2022-7-Arktower"><a href="#2022-1-2022-2-2022-7-Arktower" class="headerlink" title="2022.1~2022.2, 2022.7 Arktower"></a>2022.1~2022.2, 2022.7 Arktower</h2><p>22年寒假在家第一次尝试不依靠引擎自己写。于是看了《Windows 游戏编程从零开始》。然后用 mfc 写了一坨。直接使用 GDI 绘制非常消耗电脑资源，是及其不推荐的游戏编写方式。当时列下了一个较完整的设计表（可惜当时不会 UML）。很幸运一个行业独角兽从我当时发在 CSDN 的博客中看中了我，邀请我去他们那里实习。但可惜实习要求6个月，而我仍然要准备算法竞赛。我明白做游戏相关内容一直都是我的梦想，可既然选择了打 ACM，还是要把一件事做好。代价或许就是这样吧。</p><p>这个 demo 仍然是方舟的同人游戏，但是游戏模式上打算复刻经典的固定数值 2D RPG 游戏《魔塔》。</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230524154345522.png" alt="image-20230524154345522"></p><p>看到这个界面还是挺有成就感的，写了一大堆奇形怪状的 Win32 API… 最后，做完地图，人物移动和边栏 UI 后也作罢了。</p><p>7 月发现有个很好用的 EasyX API。虽然很多人说现代工程不用这个，缺点很多，但我也知道自己几斤几两，没必要凡事都写的那么 “现代”，直接做就是了。于是用此代替 GDI 重置了一下。这次还写了外存存储地图，也加入了道具，地图层数，算是功能比较完善了。</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230524144210338.png" alt="image-20230524144210338"></p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230524144302767.png" alt="image-20230524144302767"></p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230524144313956.png" alt="image-20230524144313956"></p><p>虽然功能比较完善，但代码比较shi，设定的文件读取规范太奇怪，后续不想继续做完内容。结束</p><h2 id="2023-1-Arktower-using-Unity"><a href="#2023-1-Arktower-using-Unity" class="headerlink" title="2023.1 Arktower using Unity"></a>2023.1 Arktower using Unity</h2><p>回到 Unity 来了。还是相同的内容，但这一次做得很完整。使用 json 进行数据存取，尽量少直接拖 prefab。</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230524144546633.png" alt="image-20230524144546633"></p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230524144645378.png" alt="image-20230524144645378"></p><p>基本框架完善，只差填充内容。</p><p>我还是很乐意看到这一版能正式可玩的，等什么时候不懒了就把内容填一填吧。</p><p>或者就不填了，因为 json 写的有点问题，导致各层需要分别加载一次资源，地图读取也有一些难排查的 bug。下次想想更好的方法吧。</p><h2 id="2023-5-PJISK（误）"><a href="#2023-5-PJISK（误）" class="headerlink" title="2023.5 PJISK（误）"></a>2023.5 PJISK（误）</h2><p><del>Project Isekai</del></p><p>想尝试写一下音游系统，干脆就顺带做 OpenGL 课设了。</p><p>目前看效果还是比较满意的。考虑平台问题，在 Windows 上确实不太好操控。然后音游的话，没有团队，写谱是件很麻烦很麻烦的事。</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230524153104733.png" alt="image-20230524153104733"></p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230524153116508.png" alt="image-20230524153116508"></p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230524153309319.png" alt="image-20230524153309319"></p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230524153331584.png" alt="image-20230524153331584"></p><p>以此为契机，未来或许可以尝试移动端开发。</p>]]></content>
    
    
    <summary type="html">学艺不精</summary>
    
    
    
    <category term="问道" scheme="https://eykenis.github.io/categories/%E9%97%AE%E9%81%93/"/>
    
    
    <category term="Games" scheme="https://eykenis.github.io/tags/Games/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络知识梳理</title>
    <link href="https://eykenis.github.io/2023/05/05/computernetwork/"/>
    <id>https://eykenis.github.io/2023/05/05/computernetwork/</id>
    <published>2023-05-05T08:00:06.000Z</published>
    <updated>2023-07-11T04:56:57.159Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="概念和功能"><a href="#概念和功能" class="headerlink" title="概念和功能"></a>概念和功能</h1><p>参考：Computer Networking: A Top-Down Approach 配套网课, 考研计网</p><p>概念：计算机网络是互联的、自治的计算机集合。</p><p>功能：包括数据通信和资源共享等。</p><h1 id="组成及分类"><a href="#组成及分类" class="headerlink" title="组成及分类"></a>组成及分类</h1><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>硬件、软件和协议</p><h2 id="不同工作方式"><a href="#不同工作方式" class="headerlink" title="不同工作方式"></a>不同工作方式</h2><p>以下各工作方式都属于边缘部分。除了边缘部分外，核心部分用于为边缘部分提供服务。简单来说就是提供接口实现。</p><h3 id="C-S-方式"><a href="#C-S-方式" class="headerlink" title="C/S 方式"></a>C/S 方式</h3><p>（Client and Server）. 客户端与服务端的端到端服务方式。服务端处理/响应客户端发送的请求。</p><h3 id="P2P-方式"><a href="#P2P-方式" class="headerlink" title="P2P 方式"></a>P2P 方式</h3><p>（Peer to Peer）. P2P 方式下不存在专门的服务机，所有端系统既是客户又是服务器。和 C/S 方式相反，请求的主机越多响应越快。</p><h3 id="B-S-方式"><a href="#B-S-方式" class="headerlink" title="B/S 方式"></a>B/S 方式</h3><p>（Browser and Server）. 浏览器到服务器的服务方式。</p><h2 id="功能组成"><a href="#功能组成" class="headerlink" title="功能组成"></a>功能组成</h2><h3 id="通信子网"><a href="#通信子网" class="headerlink" title="通信子网"></a>通信子网</h3><p>一般包括网络层、数据链路层和物理层（OSI）</p><h3 id="资源子网"><a href="#资源子网" class="headerlink" title="资源子网"></a>资源子网</h3><p>包括应用层、表示层、会话层和传输层（OSI）</p><h2 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h2><ol><li><p>按分布范围分类</p><p> 广域网WAN（交换技术）、城域网MAN、局域网LAN（广播技术）、个人区域网PAN。应该按最大通信距离和实现技术分类，而不是主机距离。</p></li><li><p>按使用者分类</p><p> 公用网和专用网</p></li><li><p>按交换技术分类</p><p> 电路交换、报文交换和分组交换</p><p> 其中报文交换和分组交换使用存储转发技术。</p></li><li><p>按拓扑结构分类</p><p> 星型、环型、网状型、总线型。。</p></li><li><p>按传输技术分类</p><p> 广播网络：共享公共通信信道</p><p> 点对点网络：使用存储转发和路由选择机制</p></li></ol><h2 id="计算机网络标准化"><a href="#计算机网络标准化" class="headerlink" title="计算机网络标准化"></a>计算机网络标准化</h2><p>为了实现不同厂商软硬件连通，计算机网络必须遵从统一的标准。</p><p>目前流行的标准为 TCP/IP. 也有权威机构制定的法定标准 OSI。</p><p>标准化审批流程：</p><p>因特网草案-&gt;建议标准（RFC 文档）-&gt;（草案标准-&gt;）因特网标准</p><p>相关组织：</p><p>ISO、ITU、IEEE、IETF</p><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><h3 id="速度相关指标"><a href="#速度相关指标" class="headerlink" title="速度相关指标"></a>速度相关指标</h3><ol><li><p>速率</p><p> 每单位时间传输的数据量。</p></li><li><p>带宽</p><p> 单位时间内从某一点到另一点能通过的最高数据率。（发送速率）</p></li><li><p>吞吐量</p><p>单位时间内通过某个网络的数据量。</p></li></ol><h3 id="时间相关指标"><a href="#时间相关指标" class="headerlink" title="时间相关指标"></a>时间相关指标</h3><ol><li><p>时延</p><p> 分为<strong>发送时延</strong>（传输时延）、<strong>传播时延</strong>、<strong>排队时延</strong>和<strong>处理时延</strong>。</p><p> 发送时延：将数据从机器内部推送到信道上的时间。</p><script type="math/tex; mode=display"> 发送时延=\frac{数据长度}{信道带宽}</script><p> 传播时延：在信道上传播的时间。取决于电磁波传播速度和链路长度。</p><script type="math/tex; mode=display"> 传播时延=\frac{信道长度}{电磁波在信道上的传播速率}</script><p> 排队时延：等待输出/输入链路可用的时间。</p><p> 处理时延：寻找合适的出口信道以及检错的时间。</p></li><li><p>时延带宽积</p><p> <strong>传播时延</strong>和带宽的乘积。单位一般为 bit.</p><p> 感觉可以理解为信息通量（？），可以描述某段链路现在有多少正在传播的比特。</p></li><li><p>往返时延 RTT</p><p> 从发送数据开始，到发送方收到接收方的确认总共经过的时延。</p><p> RTT越大，在收到确认之前可以发送的数据越多。（废话）</p><script type="math/tex; mode=display"> {\rm RTT}=2×传播时延+末端处理时间</script><p> 有时候也会忽略末端处理时间。</p></li><li><p>利用率</p><p> 1） 信道利用率</p><script type="math/tex; mode=display"> 信道利用率=\frac{有数据通过时间}{(有+无)数据通过时间}</script><p> <img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230506230041895.png" alt="image-20230506230041895"></p><p> 2）网络利用率</p><script type="math/tex; mode=display"> 网络利用率=信道利用率加权平均值</script></li></ol><h1 id="体系结构和参考模型"><a href="#体系结构和参考模型" class="headerlink" title="体系结构和参考模型"></a>体系结构和参考模型</h1><h2 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h2><p>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。</p><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><p>应用层、传输层、网际层、网络接口层。</p><p>要注意 OSI 的网络层是无连接和面向连接都有，而 TCP/IP 的网络层是无连接；OSI 的传输层是面向连接的，而 TCP/IP 的传输层是无连接+面向连接。</p><h3 id="TCP-IP-协议栈"><a href="#TCP-IP-协议栈" class="headerlink" title="TCP/IP 协议栈"></a>TCP/IP 协议栈</h3><p>应用层包括 HTTP、FTP、DNS 等协议。</p><p>传输层包括 TCP、UDP 等协议。</p><p>网际层为 IP 协议。</p><p>网络接口层包括 Ethernet、ATM、Frame Relay 等。</p><h2 id="5层模型"><a href="#5层模型" class="headerlink" title="5层模型"></a>5层模型</h2><p>放一张图看一下数据封装与解封装。</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230506232455682.png" alt="image-20230506232455682"></p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="C-S-通信方式"><a href="#C-S-通信方式" class="headerlink" title="C/S 通信方式"></a>C/S 通信方式</h2><p>服务端特点：</p><ul><li>主机永远在线</li><li>有固定 IP</li></ul><p>客户端特点：</p><ul><li>与服务端连接</li><li>连接非长时间，通常是间歇连接</li><li>不与其他客户端通信</li><li>动态 IP</li></ul><h3 id="C-S-实例：HTTP"><a href="#C-S-实例：HTTP" class="headerlink" title="C/S 实例：HTTP"></a>C/S 实例：HTTP</h3><p>客户端 -&gt; web browser，服务端 -&gt; web server</p><h2 id="P2P-通信方式"><a href="#P2P-通信方式" class="headerlink" title="P2P 通信方式"></a>P2P 通信方式</h2><p>特点：</p><ul><li>没有 always-on server</li><li>任意 peer 可以向其他 peer 提供服务，或接受服务</li><li>peers 直接 communicate</li><li>与 C/S 中的客户端一样，非长时间连接，且动态 IP</li><li>网络鲁棒性强</li></ul><h3 id="P2P-实例：P2P-文件共享"><a href="#P2P-实例：P2P-文件共享" class="headerlink" title="P2P 实例：P2P 文件共享"></a>P2P 实例：P2P 文件共享</h3><h2 id="多主机进程间通信"><a href="#多主机进程间通信" class="headerlink" title="多主机进程间通信"></a>多主机进程间通信</h2><p>单一主机内进程间通信：defined by OS</p><p>多主机间进程：exchanging message</p><ul><li><p>客户端进程初始化本次通话（communication），服务端进程等待连接。</p></li><li><p>使用传输层创建的 socket 进行通信。</p></li></ul><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230511170614277.png" alt="image-20230511170614277"></p><ul><li>每个对话中，<strong>2</strong> sockets are involved. 每端各一个。</li></ul><h3 id="定址"><a href="#定址" class="headerlink" title="定址"></a>定址</h3><p>每个进程需要一个 identifier. 我们给每个主机设置一个独有的 32 位 IP 地址。然后，再设置一个端口。端口指向我们具体的进程。</p><h2 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h2><p>协议要素：</p><ul><li>定义 exchanged message 的类型（request，respone）</li><li>定义 message 的语法。</li><li>定义 message 语义。</li><li>定义 rules. 在发送或接收信息后进行什么动作。</li></ul><h3 id="open-protocols"><a href="#open-protocols" class="headerlink" title="open protocols"></a>open protocols</h3><ul><li>在 RFC 中定义。所有人都可以查看协议内容</li><li>allows for interoperability</li><li>实例：HTTP、SMTP</li><li>独立于系统平台。不受主机影响</li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><p>一个 web page 包含各种各样的对象。包括 html 文件、jpg 图像、等等。每个对象都有自己的 URL. HTTP 使用的是 C/S 模式。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>使用 TCP 传输协议。通常 port 80.</li><li>HTTP 是无状态协议。</li></ul><h3 id="non-persistent-HTTP"><a href="#non-persistent-HTTP" class="headerlink" title="non-persistent HTTP"></a>non-persistent HTTP</h3><ul><li>最多只有一个 Web 对象发送 TCP 连接请求。传输多个对象就需要建立多个连接。</li><li>第一步（1）：HTTP 客户端初始化一个指向 HTTP 服务端的 TCP 连接。</li><li>第一步（2）： HTTP 服务端接收连接，完成连接后通知服务端。</li><li>第二步：客户端将 HTTP request message 息发送至 TCP 套接字（Socket）。消息包括客户端希望获得的<strong>单个</strong>对象。</li><li>第三步：HTTP 服务端接收消息后，将 response message 发送至它的 TCP 套接字。</li><li>第四步：HTTP 服务端关闭 TCP 连接</li><li>第五步：HTTP 客户端接收到 response message，然后显示对应的 html file.</li><li>第六步：假如解析 html 后，其中又有许多 referenced objects，那么又需要重复 1-5 步来获取这些对象的内容。</li></ul><p>问题：一次单对象的 non-persistent HTTP 传输需要多长时间：</p><p>答：2 个 RTT + 传输文件所需时间（time to trasmit file）</p><h3 id="persistent-HTTP"><a href="#persistent-HTTP" class="headerlink" title="persistent HTTP"></a>persistent HTTP</h3><p>persistent HTTP 可以将传输时间从 2 rtts + trasmit time 缩减到 1 rtt + transmit time. 因为传输多个对象只需要初始化一次了。</p><ul><li>TCP 连接建立后，多个对象都可以向单一 TCP 连接进行<strong>串行</strong>传输。</li><li>和 non-persisent HTTP 不同，在发送 response message 后不会立即关闭连接，而是保持开启。</li></ul><h3 id="HTTP-格式"><a href="#HTTP-格式" class="headerlink" title="HTTP 格式"></a>HTTP 格式</h3><ol><li><p>request message</p><ul><li><p>request line. 请求方法+URL+其他（HTTP 协议版本）。例： <code>GET xxx.com/index.html HTTP/1.1\r\h</code>。除了 <code>GET</code> 方法外，还有 <code>POST</code>, <code>HEAD</code>, <code>PUT</code> 等。</p></li><li><p>header lines. 包括发出请求的主机名称、浏览器类型、对象类型、首选语言、连接是否 keep-alive 等附加信息。</p></li><li><p>body. 并不是必要。用于发送其他附加信息。</p><p>  <img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230514145819758.png" alt="image-20230514145819758"></p></li></ul></li><li><p>response message</p><ul><li>status line. 版本号+状态码+短消息。e.g. <code>HTTP/1.1 200 OK</code></li><li>header lines. 包括时间、服务端类型等附加信息。</li><li>body. 包括需要传输的对象本身。</li></ul></li></ol><h3 id="HTTP-各版本"><a href="#HTTP-各版本" class="headerlink" title="HTTP 各版本"></a>HTTP 各版本</h3><p><strong>HTTP/0.9</strong></p><p>唯一单行命令：GET URL，如 <code>GET /mypage.html</code></p><p><strong>HTTP/1.0</strong></p><p>引入了版本信息、请求响应头等，格式已经完整</p><p><strong>HTTP/1.1</strong></p><p>对 HTTP/1.0 进行了标准化，消歧义。HTTP/1.1 默认建立 persistent HTTP 连接。</p><p><strong>HTTP/2</strong></p><p>HTTP/2 不再是一个 ASCII 文本协议，而是二进制协议。</p><p>HTTP/2 支持多路复用，移除了 HTTP/1.x 中对顺序和阻塞的约束。</p><p>HTTP/2 压缩了标头。</p><p><strong>HTTP/3</strong></p><p>…</p><h3 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h3><p>100 Continue</p><p>200 OK</p><p>202 Accepted</p><p>300 Multiple Choice</p><p>301 Moved Permanently</p><p>302 Found</p><p>400 Bad Request</p><p>401 Unauthorized</p><p>404 Not Found</p><p>502 Timeout</p><h3 id="Cookies-技术"><a href="#Cookies-技术" class="headerlink" title="Cookies 技术"></a>Cookies 技术</h3><p>cookies 用于维护用户和服务器的状态。</p><p>包括四个组件：</p><ol><li>cookie header line of HTTP response message</li><li>cookie header line in next HTTP request message</li><li>cooke file kept on user’s host</li><li>back-end database at Website</li></ol><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230514151403686.png" alt="image-20230514151403686"></p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>安全 HTTP 协议，端口 443. 通过 SSL 或者 TLS 加密，验证访客身份，保护数据完整性。</p><h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><p>以 ASCII 码格式控制连接，传输控制信息。</p><blockquote><p>通常端口 21，7位 ASCII 码。</p></blockquote><p>FTP 也是基于 C/S 模式的协议。</p><p>过程：</p><ol><li>登录。需要 FTP 地址，可能需要用户名和密码。</li><li>使用 TCP 进行可靠传输。</li></ol><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230607222650887.png" alt="image-20230607222650887"></p><p>Anonymous FTP 服务器：可以使用户与远程主机建立连接且以匿名身份从远程主机上拷贝文件，而不需要注册。</p><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><p>电子邮件包括两个部分：信封、内容</p><ul><li>信封：电子邮件地址</li><li>内容<ul><li>首部：1. 发件人电子邮件地址 2. 收件人电子邮件地址 3. 主题 4. 发送日期</li><li>主体。电子邮件内容</li></ul></li></ul><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230607223802112.png" alt="image-20230607223802112"></p><p>用户代理：电子邮件的客户端软件</p><p>SMTP 是一种基于 TCP 连接的应用层协议，用于电邮发送，端口 25. </p><p>POP3/IMAP 是基于 TCP 连接的应用层协议，用于电邮接收。</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230607225307893.png" alt="image-20230607225307893"></p><p>SMTP 无法传输二进制对象，只支持 ASCII 编码，且长度限制比较大。</p><p>因此，通用因特网邮件扩充 MIME 被用于将其他内容转化成 7 位 ASCII 编码，从而通过 SMTP 传输。</p><p>POP3 协议即第三代 POP（邮局）协议，端口号 110.</p><p>IMAP 网际报文存取协议比 POP 更复杂。使用 IMAP 程序打开 IMAP 服务器的邮箱时，用户可以看到邮箱的首部，打开某个邮件时，才会把完整的主体传到计算机上。IMAP 允许用户多平台随时阅读处理邮件，也允许只读取邮件的一个部分（正文与附件分开）。</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230607232845664.png" alt="image-20230607232845664"></p><p><strong>现代万维网电子邮件。从服务器到用户代理的收发基于 HTTP。</strong></p><h2 id="DNS-域名解析系统"><a href="#DNS-域名解析系统" class="headerlink" title="DNS 域名解析系统"></a>DNS 域名解析系统</h2><p>域名解析顺序：</p><ol><li>浏览器缓存</li><li>本机hosts文件</li><li>路由缓存</li><li>均没有，向客户端发送域名</li><li>DNS服务器（本地域名、顶级域名、根域名等多级服务器）迭代解析，递归查询</li><li>传输回解析结果 IP</li><li>DNS 传输层采用 UDP 协议实现</li></ol><h2 id="DHCP（动态主机配置协议）"><a href="#DHCP（动态主机配置协议）" class="headerlink" title="DHCP（动态主机配置协议）"></a>DHCP（动态主机配置协议）</h2><p>一种局域网协议。属于应用 UDP 的应用层协议。</p><p>作用：为临时接入局域网的用户分配 IP 地址、子网掩码、默认网关、DNS 服务器名称与 IP 地址等内容。</p><p>为主机配置 IP 时，我们通常需要配置 IP 地址、子网掩码和默认网关，这称为静态配置。</p><h2 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h2><p>一种分布式的基于距离向量的路由选择协议。</p><p>RIP 要求路由器中维护一个表，记录到每一个其他网络的最佳距离。</p><p>RIP 要求距离 $\leq$ 15，距离 16 表示网络不可达。</p><p>RIP 原理：初始只有相邻节点的距离信息。每次更新都交换相邻节点的 RIP 表信息并更新，原理类似 Bellman-Ford 算法。</p><blockquote><p>每一定时间进行一次更新。如果多次更新都没有收到某个相邻节点的信息，就认为该节点已不在网络中，相关表项置为 16（不可达）.</p></blockquote><p>RIP 在传输层使用的协议是 UDP.  传输过程中，可将封装好的 RIP 报文封装到 UDP 数据报中。</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230614112402175.png" alt="image-20230614112402175"></p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>功能：</p><ol><li>建立在主机上，实现进程与进程的通信。</li><li>复用与分用。复用：应用层所有应用进程都可以通过传输层传输信息到网络层；分用：传输层从网络收到数据后，交付给应用层指定的应用进程。</li><li>对收到的报文段进行差错检测</li></ol><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>主机IP地址:端口号。用于唯一标识主机中的某个进程。</p><p>一些重要的端口号：</p><p>FTP-&gt;21</p><p>TELNET-&gt;23</p><p>SMTP-&gt;25</p><p>DNS-&gt;52</p><p>TFTP-&gt;69</p><p>HTTP-&gt;80</p><p>SNMP-&gt;161</p><p>HTTPS-&gt;443</p><h2 id="应用层对传输协议的要求"><a href="#应用层对传输协议的要求" class="headerlink" title="应用层对传输协议的要求"></a>应用层对传输协议的要求</h2><ul><li>数据完整性（文件传输，网上交易）</li><li>时效性（多媒体通话，在线游戏）</li><li>吞吐量（Live）</li><li>安全性</li></ul><h2 id="TCP-Transmission-Control-Protocol"><a href="#TCP-Transmission-Control-Protocol" class="headerlink" title="TCP(Transmission Control Protocol)"></a>TCP(Transmission Control Protocol)</h2><p>TCP 面向连接，提供全双工通信。</p><p>TCP 确保：1. 可靠传输 2. 流量控制 3. 拥塞控制</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230511172941967.png" alt="image-20230511172941967"></p><p>TCP 报文段首部格式：</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230610133235052.png" alt="image-20230610133235052"></p><p>4x5. </p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230610133655515.png" alt="image-20230610133655515"></p><p>窗口：允许接收的数据量。</p><p>检验和：加上 12B 伪首部，第四个字段为 6.</p><p>确认号与数据偏移的区别：</p><p>紧急指针：紧急数据的字节<strong>数量</strong></p><p>选项：其他扩展功能。</p><h3 id="TCP-连接管理"><a href="#TCP-连接管理" class="headerlink" title="TCP 连接管理"></a>TCP 连接管理</h3><p>TCP 连接建立采用 C/S 方式。<strong>发起方</strong>为客户端。</p><p>三次握手：</p><ol><li>客户端发送连接请求报文段。无应用层数据。SYN=1, ACK=0, 序号=x</li><li>服务器为 TCP 连接分配缓存与变量，并返回确认报文段。无应用层数据。SYN=1, ACK=1, 序号=y, 确认号=x+1.</li><li>客户端为 TCP 连接分配缓存与变量，像服务器返回确认的确认，可以携带应用层数据。SYN=0, ACK=1 , 序号=x+1, 确认号=y+1</li></ol><blockquote><p>SYN 洪泛攻击即客户端不断发送 TCP SYN（进行第一次握手），并对服务器不响应第三次握手，导致服务器分配许多 TCP 缓存但都处在挂起状态</p><p>解决办法：SYN cookie</p></blockquote><p>四次挥手：</p><ol><li>客户端发送连接释放报文段。FIN=1，序号=x</li><li>服务器回送一个确认报文段。ACK=1, 确认号=x+1</li><li>服务器发送连接释放报文段。FIN=1，ACK=1，确认号=x+1</li><li>客户端回送一个确认报文段，等到 2MSL（最长报文段寿命）后，连接彻底关闭。</li></ol><h3 id="TCP-可靠传输"><a href="#TCP-可靠传输" class="headerlink" title="TCP 可靠传输"></a>TCP 可靠传输</h3><p>只有应用层和传输层能实现保障传输可靠性的逻辑，网络层及之下的都只能尽最大努力交付，而不能保证可靠传输。</p><p>TCP 可靠传输机制：</p><ol><li>校验。增加伪首部用于校验。</li><li>序号。序号字段指代报文段第一个字节的序号，用以保证传输内容位置正确。</li><li>确认。表示确认，并提示期待接收的下一个序号。如果发生了传输顺序不正确的问题，TCP 默认使用累计确认。</li><li>重传。重传发生的情况：（1）累计确认的配套措施，发送冗余 ACK.（2）超时重传。TCP 发送方在规定时间内没有收到接收方的收到确认，就要重传。对于超时重传的时间规定，一般采用动态改变，计算加权平均往返时间 RTTs。</li></ol><h3 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h3><p>TCP 使用滑动窗口实现流量控制。</p><p>接收方根据自己接收缓存的大小，在确认报文段中设置窗口字段通知发送方窗口大小 x。于是，<strong>在收到下一个接收方确认前</strong>，发送方可以从确认号的位置开始，连续发送大小总计 x 的内容。</p><p><strong>但是，超时重传机制不受窗口大小影响</strong>。</p><p>另外，当接收方收到零窗口确认时，就启动持续计时器。如果持续计时器时间到期，发送方就发送一个探测报文段，接收方给出现在的窗口值。如果仍是 0，就重新设计持续计时器。</p><h3 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h3><p>与接收方类似，发送方的 TCP 报文首部也会使用窗口值。它根据自己估算的网络拥塞程度设置窗口值，反应当前容量。</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230610170353699.png" alt="image-20230610170353699"></p><p>图中拥塞控制方法为 TCP Tahoe，已弃用。</p><p>快重传与快恢复：</p><p>快重传：收到冗余 ACK.</p><p>快恢复：恢复 cwnd 不用降到 1，而是降到新的 ssthresh.（TCP Reno，当前常用）</p><p>ssthresh 计算方法: 发生网络拥塞后, ssthresh 变为拥塞窗口的一半值.</p><h2 id="UDP-User-Datagram-Protocol"><a href="#UDP-User-Datagram-Protocol" class="headerlink" title="UDP(User Datagram Protocol)"></a>UDP(User Datagram Protocol)</h2><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230511172930992.png" alt="image-20230511172930992"></p><p>补充性质：UDP 是面向报文的，适合一次性传输少量数据。</p><blockquote><p>为什么 UDP 什么也不保证，也有使用 UDP 的：</p><p>答：速度更快，适合实时通信。UDP 首部字段 8B， TCP 20B，UDP 开销小。而且也可以在应用层 build 追加 service 来确保这些要求。</p></blockquote><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230610003136156.png" alt="image-20230610003136156"></p><h3 id="UDP-校验"><a href="#UDP-校验" class="headerlink" title="UDP 校验"></a>UDP 校验</h3><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230610003717193.png" alt="image-20230610003717193"></p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>路由器的最高层次是网络层。例如对于家用设备，我们可以通过主机-&gt;路由-&gt;路由-&gt;主机的方式进行通信。</p><h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230611184320331.png" alt="image-20230611184320331"></p><p>IP 地址分类：</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230612160616403.png" alt="image-20230612160616403"></p><p>其中，特殊的私有 IP 地址：</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230611184746269.png" alt="image-20230611184746269"></p><h2 id="NAT（Network-Address-Translation）"><a href="#NAT（Network-Address-Translation）" class="headerlink" title="NAT（Network Address Translation）"></a>NAT（Network Address Translation）</h2><p>因为路由器对目的地址是私有 IP 地址的数据报一律不转发，通过为路由器安装 NAT 软件，我们可以将该路由器作为 NAT 路由器，其至少拥有一个有效的外部全球 IP 地址。</p><p>（俗称内网穿透）</p><p>之后，使用本地地址的主机经过 NAT 路由器进行外部地址转换，即可与外界通信。</p><p>注意 LAN 端可能有多个主机 IP，但可能共用同一个 NAT 端的 IP 地址。这时路由会选取一对空闲的 IP:端口号分配给需要发送至 WAN 的本地报文。这种方式被称为 NAPT（Network Address Port Translation）。</p><p>另一种方式为 Basic NAT，本地 IP 地址经过 NAT 转换时一一对应。</p><h2 id="子网"><a href="#子网" class="headerlink" title="子网"></a>子网</h2><p>划分子网：</p><p>将原来的 “网络号.主机号” 模式增改为 “网络号.子网号.主机号”。以此避免向 ISP（网络服务提供商）过多申请 IP 地址。 </p><p>子网划分案例：</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230612161305529.png" alt="image-20230612161305529"></p><p>将一个外部信息传给具体的主机，需要使用<strong>子网掩码</strong>。</p><p>子网掩码中，全 1 部分为非主机号，全 0 部分为主机号。通过与运算得到子网网络地址，再确定主机号。</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230612164005663.png" alt="image-20230612164005663"></p><h2 id="CIDR-无分类编址"><a href="#CIDR-无分类编址" class="headerlink" title="CIDR 无分类编址"></a>CIDR 无分类编址</h2><p>CIDR：IP 地址后加上 “/“，再写上网络前缀的位数。那么地址块中的地址就等于固定前缀，然后后面剩下的位数为主机号。类似于页表项。</p><p> <strong>应用：路由聚合，构成超网</strong>。取不同子网 IP 的最大相同前缀，来形成一个更高一级的子网。</p><p>要发送到理论最准确的位置，就使用最长前缀匹配。 </p><h2 id="ARP-Address-Resolution-Protocol"><a href="#ARP-Address-Resolution-Protocol" class="headerlink" title="ARP (Address Resolution Protocol)"></a>ARP (Address Resolution Protocol)</h2><p>在实际网络的链路上传输数据帧时需要使用物理地址。</p><p>ARP 协议根据 IP 地址获取物理（MAC）地址。</p><p>工作流程：</p><p>（如果在同一网段）</p><ol><li>查看 ARP 缓存是否有目标主机的 ARP 表项。</li><li>如果没有，就缓存该报文，然后广播一个 ARP 请求报文。目标主机会对该请求进行处理。</li><li>目标主机比较自己的 IP 地址与请求报文中的目标 IP 地址。如果相同，就发送相应报文，其中包含自己的 MAC。</li><li>原主机收到后，将目标主机的 MAC 地址加入 ARP 表，然后将与其相关的缓存报文封装好发送出去。</li></ol><p>（如果不在同一网段）</p><p>先向网关发起 ARP 请求，目标地址为网关的 IP 地址。获得网关的 MAC 地址后，将报文封装，发给网关。由网关再代为向目标主机发送报文（网关使用自己的 ARP 缓存，或者广播 ARP 请求报文）。</p><p>广播 ARP 请求分组格式：</p><p>自身IP-目标IP-自身MAC-FF-FF-FF-FF-FF-FF（目的 MAC 地址全 1，表示为广播分组）</p><p>单播 ARP 响应分组格式：</p><p>目标IP-目标 MAC 地址</p><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>用于差错报告。发送特定的 ICMP 报文。</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230613232310513.png" alt=""></p><p>ICMP 差错报告报文：</p><ol><li>终点不可达。无法向上层交付数据报。</li><li>源点抑制。因为网络拥塞而丢失数据报。</li><li>时间超过。生存时间 TTL=0 时，除了丢弃该数据报之外，还要发送时间超过报文。</li><li>参数问题。首部字段不正确时，丢弃数据报，并向源点发送参数问题报文。</li><li>改变路由（重定向）。让主机知道下次应当将数据报发送给另外的路由器（更优的路由器）。</li></ol><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230613232821823.png" alt="image-20230613232821823"></p><p>ICMP 询问报文：</p><ol><li>回送请求与回答报文。主机或路由器向特定主机发出询问，目标主机需要回送以测试可达性，并了解相关状态。</li><li>时间戳请求和回答报文。请某个主机或路由器回答当前日期与时间。</li></ol><p>应用：</p><ol><li>PING. 使用 ICMP 回送请求与回答报文。</li><li>Traceroute. 跟踪分组从源点到终点的路径。依次发送 TTL 为 1,2,3,… 的报文，每当中间路由收到 TTL 降为 0 的报文后，就发回一个时间超过差错报告报文，以此让源点知道路径上该点路由的位置。</li></ol><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>IPv6 格式：</p><p>共 128 位，分 8 组，每组 16 位，每一组用 4 个十六进制数表示，各组用:隔开，如：</p><p>1080:0:0:0:8:800:200C:417A</p><p>当 IPv6 包含其 IPv4 地址时，最后两组通常可以写成 IPv4 的十进制+ ‘.’ 形式。</p><p>IPv6 地址结构：</p><p>前 48 位为 Global ID，全球网络标识符；之后 16 位为本地子网标识符。后 64 位为主机标识符。</p><h3 id="无校验阶段"><a href="#无校验阶段" class="headerlink" title="无校验阶段"></a>无校验阶段</h3><p>IPv6 不需要校验，加快了处理速度。</p><h3 id="扩展首部代替可选字段"><a href="#扩展首部代替可选字段" class="headerlink" title="扩展首部代替可选字段"></a>扩展首部代替可选字段</h3><p>IPv6 不需要对扩展首部大小进行额外检查。</p><h3 id="即插即用"><a href="#即插即用" class="headerlink" title="即插即用"></a>即插即用</h3><p>不需要 DHCP 配置，可以自动配置 IP 地址。</p><h3 id="QoS"><a href="#QoS" class="headerlink" title="QoS"></a>QoS</h3><p>IPv6 协议可以满足 QoS，保证一定带宽和时延的应用。</p><h3 id="ICMPv6"><a href="#ICMPv6" class="headerlink" title="ICMPv6"></a>ICMPv6</h3><p>配套的增强 ICMP 协议，附加了报文类型 “分组过大”。</p><h2 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h2><p>另一种路由选择协议。和 RIP 使用分布式 Bellman-Ford 类似，OSPF 使用的是 Dijkstra 算法。</p><ol><li>向自治系统内所有路由器广播链路信息，包括它们之间链路的费用、时延、带宽等。</li><li>只在链路状态变化时执行步骤 1.</li></ol><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p>使用帧定界符，让接收端知道报文的每一帧。</p><p>透明传输：数据封装成帧要求满足透明传输条件，即数据中不会包含会被误认为控制信息的内容，以让链路层可以正确识别帧。</p><p>组成帧的方法：</p><ol><li><p>字符计数法</p><p> 字首段使用一个计数字段，标明该段帧字符数。</p><p> 缺点：如果有字首段传输时因出错改变，则后面发生多米诺效应，导致整段数据出错。</p></li><li><p>字符节填充法</p><p> 一种简单的方法是使用 SOH 和 EOT 字段。具体字段使用特定的比特组合来标识帧开始和帧结束。如果传输为 ASCII 文本，则可以使用该方法。因为 ASCII 文本不包含全部 8 位二进制数，因此不会出现误识别的情况。</p><p> 但如果不是这种情况，就需要使用字符填充法，即当数据内部出现和控制字段一样的数值时，在其前面添加一节转义字符。</p></li><li><p>零比特填充法</p><p> 首部和尾部的标识符一样，通常为 $01111110$. 然后在发送端对数据进行加工：每遇到连续的 5 个 1，就填入一个 0. 这样数据中就不会包含 $01111110$ 了。</p><p> 在解包时，每遇到连续的 5 个 1，就删除一个 0.</p></li><li><p>违规编码法</p><p> 在物理层实现。 </p><p> <img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230622141119840.png" alt="image-20230622141119840"></p></li></ol><h2 id="SAP-服务类型"><a href="#SAP-服务类型" class="headerlink" title="SAP 服务类型"></a>SAP 服务类型</h2><ol><li>有确认的面向连接服务</li><li>有确认的无连接服务（无连接为永久链路，如局域网）</li><li>无确认的无连接服务</li></ol><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p>物理层用于解决传输比特流的方法。</p><p>物理层主要任务：确定与传输媒体接口有关的特性、标准</p><h2 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a>通信基础</h2><p>经典数据通信模型：</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230507130801711.png" alt="image-20230507130801711"></p><h3 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h3><ol><li>单工通信。单方交互，只需要一条信道。</li><li>半双工。两边都可以发送或接收，但不能同时发送和接收。需要两条信道。</li><li>全双工。可以同时发送和接收。需要两条信道。</li></ol><h3 id="数据传输方式"><a href="#数据传输方式" class="headerlink" title="数据传输方式"></a>数据传输方式</h3><ol><li>串行传输。例如将一个字节的 8 个 bit 由低位到高位按顺序依次发送。</li><li><p>并行传输。例如将 8 个 bit 同时通过 8 条信道发送。相比于串行传输速度更快，费用更高。适合近距离传输。</p></li><li><p>同步传输（区块传输）。数据以一个数据区块为单位传输。传送时，先送出同步字符，再送出整批数据。</p></li><li>异步传输。数据以比特或者小组为单位传输。传送数据时要加起始位和终止位。</li></ol><h3 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h3><p><strong>码元</strong>：指一个固定时长的信号波形或数字脉冲。作为数字信号计量单位。码元宽度指时长。有 $x$ 个状态的码元被称为 $x$ 进制码元。</p><p><strong>码元传输速率</strong>：单位时间内传输的码元量。与进制无关， 只与码元宽度有关。</p><p><strong>波特</strong>：码元传输速率的单位。1 波特表示每秒传输一个码元。如果一个码元携带 $n\ {\rm bit}$ 信息量，则  $M\ {\rm Baud}$ 的码元传输速率对应每秒能传输 $Mn\ {\rm bit}$ 信息。</p><p><strong>带宽</strong>（模拟信号）：单位为 Hz. 最高频率和最低频率之间的差值。</p><p><strong>带宽</strong>（数字设备）：单位为 bit/s. 前面提到过。链路最高数据传输能力。</p><h2 id="通信定理"><a href="#通信定理" class="headerlink" title="通信定理"></a>通信定理</h2><p>前置概念：</p><p><strong>失真</strong>：带宽受限、有噪声、干扰导致的波形磨损。影响因素：码元传输速率，过快容易受磨损；信号传输距离；噪声干扰；传输媒体质量。</p><p><strong>码间串扰</strong>： 频率过高，导致接收端收到的波形失去了码元之间的清晰界限。</p><h3 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h3><p>理想低通（无噪声，带宽受限）条件下，如果要避免码间串扰，极限码元传输速率为 2W Baud. 其中 W 为信道带宽，单位 Hz.</p><p>则极限数据传输速率</p><script type="math/tex; mode=display">2W\log_2V</script><p>$V$ 指有几种码元（码元离散电平数目）。</p><h3 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h3><p>在带宽受限<strong>且有噪声</strong>的信道中，为了不产生误差，信息数据传输存在上限。</p><p><strong>信噪比</strong>：信号平均功率/噪声平均功率 $S/N$（单位 dB），或者用如下公式表示：</p><script type="math/tex; mode=display">10\lg{S\over N}</script><p>香农定理公式：</p><script type="math/tex; mode=display">W\log_2({1+{S\over N}})</script><h2 id="编码和调制"><a href="#编码和调制" class="headerlink" title="编码和调制"></a>编码和调制</h2><p>信道分类：模拟信道与数字信道（按传输的信号分），无线信号和有线信号（传输介质）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;概念和功能&quot;&gt;&lt;a href=&quot;#概念和功能&quot; class=&quot;headerlink&quot; title=&quot;概念和功能&quot;&gt;&lt;/a&gt;概念和功能&lt;/h1&gt;&lt;p&gt;参考：Computer Networking: A Top-Down Approach 配</summary>
      
    
    
    
    <category term="问道" scheme="https://eykenis.github.io/categories/%E9%97%AE%E9%81%93/"/>
    
    
  </entry>
  
  <entry>
    <title>MIT S6.081 labs 笔记</title>
    <link href="https://eykenis.github.io/2023/04/05/xv6-labs-2022/"/>
    <id>https://eykenis.github.io/2023/04/05/xv6-labs-2022/</id>
    <published>2023-04-05T02:32:21.000Z</published>
    <updated>2023-06-08T11:53:01.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="utilities"><a href="#utilities" class="headerlink" title="utilities"></a>utilities</h1><p>用时 5h 左右.</p><h2 id="Boot-xv6"><a href="#Boot-xv6" class="headerlink" title="Boot xv6"></a>Boot xv6</h2><p>配环境配了半个多小时。官网的引导还是非常清晰的。</p><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>xv6 系统 exec指令时，创建一个子进程执行该用户指令，用户函数中可能会有系统调用。这时会陷入内核态并进行操作，再返回。全部执行完后要 <code>exit</code> 来让进程退出。</p><p>调用系统调用 <code>sleep</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span>* str;</span><br><span class="line">        str = <span class="string">&quot;Usage: sleep sleeptime..\n&quot;</span>;</span><br><span class="line">        write(<span class="number">1</span>, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> time = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    sleep(time);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意标准输入的 fd 号是 0，标准输出是 1，错误输出（<code>stderr</code>）是 2.</p><p>其中，系统调用 <code>sleep(time)</code> 将当前进程挂起 <code>(time)</code> 个 tick. 如果 sleep 过程中发生信号中断，会返回剩余没睡完的时间。</p><p>可能看书不仔细，没有找到 qemu 模拟的一个 tick 是多久。Linux 下的 <code>sleep()</code> 不是按 tick 睡而是按秒睡。</p><h2 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h2><p>该任务要求用 <code>pipe</code> 实现父进程和子进程的通信，子进程写一个 byte 发送给父进程。</p><p><code>pipe()</code> 会创建一个管道，占用两个文件描述符 <code>fd[2]</code>，<code>fd[0]</code> 用于读，<code>fd[1]</code> 用于写。<code>fork()</code> 之后父进程 <code>wait()</code> 一下，等子进程做完它的事再去管道读。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">int</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pipe</span>(fd) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Pipe creation failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="keyword">if</span> (!(pid = fork())) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;%d: received ping\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">write</span>(fd[<span class="number">1</span>], <span class="string">&quot;x&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">wait</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;%d: received pong\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">        <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>));</span><br><span class="line">        <span class="built_in">read</span>(fd[<span class="number">0</span>], buf, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;message %s received\n&quot;</span>, buf);</span><br><span class="line">        <span class="built_in">free</span>(buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h2><p>用 pipeline 求素数。题目说求 35 以内的就可以，但是测的时候求 100 多也没问题。做法是在每次递归时，将待筛选的数输入 pipe 内，让下一层递归读取并筛去，筛完的数再递归到下一层。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_prime</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num, p;</span><br><span class="line">    <span class="keyword">int</span> rd;</span><br><span class="line">    <span class="keyword">if</span> ((rd = <span class="built_in">read</span>(fd, &amp;num, <span class="number">4</span>)) &amp;&amp; rd != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">// end of recursion</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;pipe read is not in int type\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!rd) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;prime %d\n&quot;</span>, num);</span><br><span class="line">    <span class="keyword">int</span> son_fd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pipe</span>(son_fd);</span><br><span class="line">    <span class="keyword">if</span> (!fork()) &#123; <span class="comment">// child</span></span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="built_in">close</span>(son_fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">test_prime</span>(son_fd[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">close</span>(son_fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span> ((rd = <span class="built_in">read</span>(fd, &amp;p, <span class="number">4</span>))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rd != <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;pipe read is not in int type\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p % num) &#123;</span><br><span class="line">                <span class="built_in">write</span>(son_fd[<span class="number">1</span>], &amp;p, <span class="number">4</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(son_fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="built_in">wait</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">pipe</span>(fd);</span><br><span class="line">    <span class="keyword">int</span> i, n = <span class="number">35</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; ++i) &#123; <span class="comment">// initialize</span></span><br><span class="line">        <span class="built_in">write</span>(fd[<span class="number">1</span>], &amp;i, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">test_prime</span>(fd[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>照着 ls 写递归版本就行。要先熟悉 <code>stat</code>、<code>dirent</code> 等描述结构体。<code>stat</code>详细可以看 <code>stat.h</code>。<code>dirent</code> 描述的是当前被读取的目录信息，其中包括索引节点号 <code>inum</code> 和目录名 <code>name</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>*</span></span><br><span class="line"><span class="function"><span class="title">fmtname</span><span class="params">(<span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[DIRSIZ+<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">char</span> *p;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find first character after last slash.</span></span><br><span class="line">  <span class="keyword">for</span>(p=path+<span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)</span><br><span class="line">    ;</span><br><span class="line">  p++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return name.</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strlen</span>(p) &gt;= DIRSIZ)</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  <span class="built_in">memmove</span>(buf, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">  *(buf + <span class="built_in">strlen</span>(p)) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span>* path, <span class="keyword">char</span>* target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">char</span>* p;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = <span class="built_in">open</span>(path, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fstat</span>(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(st.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> T_FILE:</span><br><span class="line">            <span class="comment">// printf(&quot;%s is a file, fmtname: %s, target: %s\n&quot;, path, fmtname(path), target);</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(target, <span class="built_in">fmtname</span>(path))) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_DIR:</span><br><span class="line">        <span class="comment">// printf(&quot;%s is a directory\n&quot;, path);</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strlen</span>(path) + DIRSIZ + <span class="number">1</span> + <span class="number">1</span> &gt; <span class="built_in"><span class="keyword">sizeof</span></span>(buf)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">            p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">            *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">read</span>(fd, &amp;de, <span class="built_in"><span class="keyword">sizeof</span></span>(de)) == <span class="built_in"><span class="keyword">sizeof</span></span>(de)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (de.inum == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">memmove</span>(p, de.name, DIRSIZ);</span><br><span class="line">                p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) || !<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">find</span>(buf, target);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: find directory filename..\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">find</span>(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>模拟题。把当前标准输入中的内容存下来，接到 argv 后面，再在子进程中 <code>exec</code> 就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy args to command ptr</span></span><br><span class="line">    <span class="keyword">char</span> *command[MAXARG];</span><br><span class="line">    argc--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">        command[i] = argv[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read std input to buf, and append buf</span></span><br><span class="line">    <span class="keyword">int</span> input_size, argptr;</span><br><span class="line">    <span class="keyword">while</span> ((input_size = <span class="built_in">read</span>(<span class="number">0</span>, buf, <span class="built_in"><span class="keyword">sizeof</span></span>(buf))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        argc++, argptr = <span class="number">0</span>;</span><br><span class="line">        command[argc - <span class="number">1</span>] = <span class="built_in">malloc</span>(<span class="number">64</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input_size; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = buf[i];</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                argc++, argptr = <span class="number">0</span>;</span><br><span class="line">                command[argc - <span class="number">1</span>] = <span class="built_in">malloc</span>(<span class="number">64</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>));</span><br><span class="line">                <span class="keyword">if</span> (argc &gt; MAXARG) &#123;</span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;xargs: too many args!\n&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                command[argc - <span class="number">1</span>][argptr++] = ch;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use childproc to execute the command follows xargs</span></span><br><span class="line">    <span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line">        <span class="built_in">exec</span>(argv[<span class="number">1</span>], command);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">wait</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>最后 <code>make grade</code> 99 分，原来还需要上传一个完成时间。</p><p><code>echo 5 &gt; time.txt &amp;&amp; make grade</code></p><p><code>make grade</code>，100/100</p><h1 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h1><p>用时 4h 左右。</p><p>首先是 riscv64 gdb 的安装。直接 <code>riscv64-unknown-elf-gdb</code> 之后是这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">riscv64-unknown-elf-gdb: command not found</span><br></pre></td></tr></table></figure><p>先拷贝一份 gdb 源码到本地，再 <code>mkdir build &amp;&amp; cd build</code>.</p><p>执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libgmp-dev</span><br><span class="line">../configure --prefix=/usr/local --with-python=/usr/bin/python --target=riscv64-unknown-elf --enable-tui=yes</span><br><span class="line">make -j$(nproc)</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>完成 <code>riscv</code> 版本 gdb 的安装。</p><p>再执行 <code>riscv64-unknown-elf-gdb</code>，就能启动 gdb 了。</p><p>（P.S. 做完 util 之后觉得 wsl2 太慢太卡了，还是要上 Ubuntu. 但是太久没用 Ubuntu, 到这一步花了我好几个小时 orz）</p><p>折腾完环境终于能进入正题了</p><h2 id="Using-gdb"><a href="#Using-gdb" class="headerlink" title="Using gdb"></a>Using gdb</h2><p>在一个终端启动 <code>make qemu-gdb</code>，记录 <code>tcp::26000</code></p><p>在另一个终端打开 gdb（riscv版或者 <code>gdb-multiarch</code> ）, 并输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target remote localhost:26000</span><br></pre></td></tr></table></figure><p>完成连接。进入 kernel</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file kernel/kernel</span><br></pre></td></tr></table></figure><p>然后按说明调试.</p><p>或者直接 <code>gdb-multiarch -x .gdbinit</code></p><p>建议先阅读 xv6 books 的第四节。</p><p>问题答案：</p><p>Looking at the backtrace output, which function called <code>syscall</code>?</p><blockquote><p><code>usertrap()</code> in <code>kernel/trap.c</code></p></blockquote><p>What is the value of <code>p-&gt;trapframe-&gt;a7</code> and what does that value represent? (Hint: look <code>user/initcode.S</code>, the first user program xv6 starts.)</p><blockquote><ol><li>sys status. EXEC or EXIT. in start at user/initcode.S, a7 is assigned with SYS_EXEC.</li></ol></blockquote><p>What was the previous mode that the CPU was in?</p><blockquote><p>usermode. check sstatus:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p/t $sstatus</span><br><span class="line"><span class="meta">$</span><span class="bash">5 = 100010</span></span><br></pre></td></tr></table></figure><p>(Here we do as instruction, and if we check ‘p’ we’ll get ‘value has been optimized out’. It’s because creation of *p is after our breakpoint! what a fool is me.)</p></blockquote><p>Write down the assembly instruction the kernel is panicing at. Which register corresponds to the varialable <code>num</code>?</p><blockquote><p>80002078:    00002903              lw    s2,0(zero) # 0 <_entry-0x80000000></p><p>s2.</p></blockquote><p>Why does the kernel crash? Hint: look at figure 3-3 in the text; is address 0 mapped in the kernel address space? Is that confirmed by the value in <code>scause</code> above? (See description of <code>scause</code> in <a href="https://pdos.csail.mit.edu/6.828/2022/labs/n//github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">RISC-V privileged instructions</a>)</p><blockquote><p>check scause, <code>$1 = 13</code>.</p><p>13 represents a load page fault. That’s because we load data from addr 0. 0 is not avaliable. Kernel space begins at 0x80000000.</p></blockquote><p>What is the name of the binary that was running when the kernel paniced? What is its process id (<code>pid</code>)?</p><blockquote><p>initcode.</p><p>pid is 1.</p><p>use p/x *p.</p></blockquote><h2 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h2><p>看不太懂。。这是要干啥。跟着 hint，找到 <code>syscall.c</code> 下的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fetch the nth 32-bit system call argument.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">argint</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  *ip = argraw(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取系统调用的第 n 个参数。</p><p>然后还找到有个函数 <code>myproc()</code> 返回当前正在运行的进程的 <code>proc</code> 结构体。</p><p>在 proc 中新建一个掩码变量，获取进行的系统调用号后用掩码与一下就知道现在调用什么了。根据 hint，还要注意 fork 时为子进程也 copy 一下掩码这个变量。</p><p>另外怎么没有地方提起返回值的问题。这里测试程序其实是规定了 <code>trace</code> 返回 0 的。</p><p><a href="[finished system call tracing · Eykenis/xv6-labs-2022@68a932a (github.com">commit</a>](<a href="https://github.com/Eykenis/xv6-labs-2022/commit/68a932a62dd3d357da8e84c9a77d3046da12443f">https://github.com/Eykenis/xv6-labs-2022/commit/68a932a62dd3d357da8e84c9a77d3046da12443f</a>))</p><h2 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h2><p>该系统调用输出一个 <code>sysinfo</code> 结构体。其中包括空闲内存大小和使用中的进程数量两个信息。</p><p>先将 sysinfotest 加入，会编译失败。去 <code>user.h</code> 声明一下 <code>sysinfo</code> 的结构体和函数。</p><h3 id="xv6-的内存管理"><a href="#xv6-的内存管理" class="headerlink" title="xv6 的内存管理"></a>xv6 的内存管理</h3><p>xv6 将内存以链表的形式将空闲空间组织起来。见 kalloc.c 中对 <code>run</code> 和 <code>kmem</code> 的定义。<code>run</code> 就是一个单链表的定义。</p><p><code>kmem</code> 的三个参数中，<code>freelist</code> 为空闲页链表。我们可以在 <code>kalloc</code> 函数中窥见 <code>kmem</code> 的运作方式。注意到每次 <code>kalloc</code> 都<strong>必须加锁</strong>。因为页表相关属于临界操作。</p><p>我们可以照着写 <code>freememcount</code> 函数用于计算页表空闲大小。虽然这里我们不修改临界资源，但为了避免结果不一致，还是加锁为好。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">freememcount</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 freepg_cnt = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span>* <span class="title">r</span>;</span></span><br><span class="line">  </span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">while</span> (r) &#123;</span><br><span class="line">    r = r-&gt;next;</span><br><span class="line">    freepg_cnt++;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> freepg_cnt * PGSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再来看<code>proc.c</code>. 所有的进程都在 <code>struct proc proc[NPROC]</code> 这个全局变量中，我们只需要遍历这个 proc 数组，然后看看状态不为 <code>UNUSED</code> 的有多少个就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">procnum</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span>;</span></span><br><span class="line">  <span class="keyword">int</span> proc_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (p = proc; p != &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;state != UNUSED) &#123;</span><br><span class="line">      proc_count++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> proc_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在还有一个问题，我们这些操作都是在内核空间做的，我们需要将信息拷贝至用户空间。参考 <code>copyout</code> 函数的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_sysinfo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 st;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  argaddr(<span class="number">0</span>, &amp;st); <span class="comment">// first arg in sysinfo() (userspace)</span></span><br><span class="line"></span><br><span class="line">  info.freemem = freememcount();</span><br><span class="line">  info.nproc = procnum();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (copyout(p-&gt;pagetable, st, &amp;info, <span class="keyword">sizeof</span>(info)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Eykenis/xv6-labs-2022/commit/085f6309180d971023c5ce2b05d57b43ab92e553">commit</a></p><h1 id="Pgtbl"><a href="#Pgtbl" class="headerlink" title="Pgtbl"></a>Pgtbl</h1><p>看了很久的 book</p><h2 id="Speed-up-system-calls"><a href="#Speed-up-system-calls" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h2><p>应该属于进程间共享内存方式的通信。要求在内核和用户程序之间创建一个只读页，然后将 struct syscall 存入只读页中 USYSCALL 映射的地址。</p><p><code>ugetpid()</code> 实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ugetpid(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> *<span class="title">u</span> =</span> (struct usyscall *)USYSCALL;</span><br><span class="line">  <span class="keyword">return</span> u-&gt;pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说我们要在进程创建时，将进程用户空间 USYSCALL 这个地址位置存入 usyscall 的内容。</p><p>观察 <code>memlayout.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// riscv.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGSIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVA (1L &lt;&lt; (9 + 9 + 9 + 12 - 1))</span></span><br><span class="line"><span class="comment">// memlayout.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRAMPOLINE (MAXVA - PGSIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRAPFRAME (TRAMPOLINE - PGSIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USYSCALL (TRAPFRAME - PGSIZE)</span></span><br></pre></td></tr></table></figure><p>xv6 使用 Sv39 RISC-V 架构，64 位虚拟地址只有低 39 位被使用。</p><p>在转换物理地址的过程中，虚拟地址高 27 位用于定位 PTE。PTE 将指向一个 44 位的带标记位的物理页号，然后虚拟地址的低 12 位为偏移。最后得到一个 56 位的物理地址。</p><p>所以，对于我们的进程，它拥有 2^39^ = 512G 空间，PGSIZE = 4M. 地址空间自顶向下分别为 trampoline(1 页)、trapframe(1 页)、heap, user stack 和 user text and data.</p><p>heap 是自顶向下增长的。所以，我们要将 usyscall 的内容存在堆底也就是进程虚拟地址的第三页。</p><p>hint 中的 <code>mempages</code> 即用于进行 proc 结构体中各个变量和地址空间的映射。</p><p>问题：写完之后 test，发生了 scause，signal=15，为 page fault. 访问页面出错了。</p><p>于是上 printf 调试大法。</p><p>最后发现子进程中 fork 会导致 ugetpid 运行缺页。</p><p>继续排查，发现是 allocproc 函数出了问题，应当在 proc_pagetable 之前就分配好 usyscall 的空间。<strong>因为proc_pagetable() 为进程各项分配页表映射。如果分配映射时 usyscall 还没被分配空间的话，肯定会导致 page fault.</strong> </p><p>又是一个不仔细导致的错误，有点低级。</p><p>再回顾整个 allocproc 过程：</p><ol><li>薅一个空闲进程过来</li><li>为进程内指针分配物理空间（kalloc）</li><li>创建一个页表，进行页表映射，以此创建进程各个项的用户空间地址。</li><li>创建新的上下文。</li></ol><p>问题：</p><blockquote><p>Which other xv6 system call(s) could be made faster using this shared page? Explain how.</p></blockquote><p>fork(). We add a pointer *proc in struct usyscall, then children could access there parent in USYSCALL page.</p><p><a href="https://github.com/Eykenis/xv6-labs-2022/commit/f55b2c4b25f1cf675a27d8ae8ac495f2d3b727db">commit</a></p><h2 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h2><p>主要参考 freewalk 函数。这个 freewalk 用于释放页表映射，过程中访问了各个页表。</p><p>看 freewalk 的时候注意了 freewalk 考虑了 riscv 的多级页表，会进行相应的递归调用。而且遇到 leaf 页表项会 panic. 这说明 freewalk 之前要先释放掉所有 leaf pagetable.</p><p>总之照着写就能写出来了。注意格式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recur_vmprint</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span> ((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>) &#123;</span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; level; ++j)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;.. &quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;..%d: pte %p pa %p\n&quot;</span>, i, pte, child);</span><br><span class="line">      recur_vmprint((<span class="keyword">pagetable_t</span>)child, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pte &amp; PTE_V)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; level; ++j)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;.. &quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;..%d: pte %p pa %p\n&quot;</span>, i, pte, PTE2PA(pte));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">vmprint</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">  recur_vmprint(pagetable, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Eykenis/xv6-labs-2022/commit/aa9f58f63e69265100b584980b6f1935309e00d9">commit</a></p><p>问题：</p><p>Explain the output of <code>vmprint</code> in terms of Fig 3-4 from the text. What does page 0 contain? What is in page 2? When running in user mode, could the process read/write the memory mapped by page 1? What does the third to last page contain?</p><blockquote><p>page 0 contains text and data seg.</p><p>page 2 contains stack. (page 1 as stack gurad)</p><p><strong>SEE IN <code>exec()</code> IN exec.c</strong></p><p>NO.</p><p>511 to 509: trampoline, trapframe, and usyscall.</p><p>so 509 contains the struct <code>usyscall</code>.</p></blockquote><h2 id="Detect-which-pages-have-been-accessed"><a href="#Detect-which-pages-have-been-accessed" class="headerlink" title="Detect which pages have been accessed"></a>Detect which pages have been accessed</h2><p>alloc: if so, PTE in TLB, PTE_V is true</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pte_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">walk</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, uint64 va, <span class="keyword">int</span> alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">    <span class="keyword">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      pagetable = (<span class="keyword">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!alloc || (pagetable = (<span class="keyword">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PTE_A: RISC-V privileged architecture manual     Figure 4.15</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230525144139109.png" alt="image-20230525144139109"></p><p>Be sure to clear <code>PTE_A</code> after checking if it is set. Otherwise, it won’t be possible to determine if the page was accessed since the last time <code>pgaccess()</code> was called (i.e., the bit will be set forever).</p><p>不是很理解这句？</p><p>或许是因为 pgaccess 本身也会为 PTE_A 置 1，需要清除？</p><h1 id="Traps"><a href="#Traps" class="headerlink" title="Traps"></a>Traps</h1><h2 id="RISC-V-assemply"><a href="#RISC-V-assemply" class="headerlink" title="RISC-V assemply"></a>RISC-V assemply</h2><p>全是问题。了解 RISCV 汇编。</p><p>Which registers contain arguments to functions? For example, which register holds 13 in main’s call to <code>printf</code>?</p><blockquote><p>a0, a1, a2, …</p><p>a2 holds printf.</p></blockquote><p>Where is the call to function <code>f</code> in the assembly code for main? Where is the call to <code>g</code>? (Hint: the compiler may inline functions.)</p><blockquote><p>call no f or g. JUST calculated the result as 12.</p></blockquote><p>At what address is the function <code>printf</code> located?</p><blockquote><p>0x642</p></blockquote><p>What value is in the register <code>ra</code> just after the <code>jalr</code> to <code>printf</code> in <code>main</code>?</p><blockquote><p>0x38 the return address.</p></blockquote><p>Run the following code.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unsigned int i = 0x00646c72;</span><br><span class="line">printf(&quot;H%x Wo%s&quot;, 57616, &amp;i);</span><br><span class="line">     </span><br></pre></td></tr></table></figure><p>What is the output? <a href="https://www.asciitable.com/">Here’s an ASCII table</a> that maps bytes to characters.</p><p>The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set <code>i</code> to in order to yield the same output? Would you need to change <code>57616</code> to a different value?</p><p><a href="http://www.webopedia.com/TERM/b/big_endian.html">Here’s a description of little- and big-endian</a> and <a href="https://www.rfc-editor.org/ien/ien137.txt">a more whimsical description</a>.</p><blockquote></blockquote><p>In the following code, what is going to be printed after <code>&#39;y=&#39;</code>? (note: the answer is not a specific value.) Why does this happen?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;x=%d y=%d&quot;, 3);</span><br></pre></td></tr></table></figure><p>&gt;</p><h2 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h2><p>了解程序栈的构造就很好写了。</p><p>主要还是读 xv6 book.</p><p>按照 hint 写 <code>r_fp()</code> 函数获取当前函数栈帧。</p><p>获取栈帧后，<code>PGROUNDUP</code> 一下获取栈<strong>底</strong>（xv6 的栈结构为向下增长）。当前栈帧 <code>-8</code> 所指向的位置是当前函数的返回地址，而指向的上一个地址是前一个被调用函数的帧地址。于是 <code>fp-8</code> 就可以获得当前函数返回地址，而 <code>fp-16</code> 就可以返回前一个函数帧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 fp, top;</span><br><span class="line">  fp = <span class="built_in">r_fp</span>();</span><br><span class="line">  top = <span class="built_in">PGROUNDUP</span>(fp);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (fp != top)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, *(uint64*)(fp - <span class="number">8</span>));</span><br><span class="line">    fp = *(uint64*)(fp - <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h2><h1 id="Copy-on-Write"><a href="#Copy-on-Write" class="headerlink" title="Copy-on-Write"></a>Copy-on-Write</h1><p>这次实验就解决一个问题：</p><p>如何用写时复制技术实现 <code>fork()</code> 。</p><p>先看开头的 solution，它提到我们在这次实验中要做的：内存懒分配。只在内存真的被需要的时候才从子进程复制一份过来。</p><ol><li><code>fork()</code> 为子进程创建一个页表，页表项从子进程的虚拟页指向父进程的物理页。</li><li>子进程和父进程的页表项都标记为 read-only</li><li>标记后，两个进程其中任一尝试写这些页表时，都会触发 page fault.</li><li>page fault 被内核 handler 侦测后，为 faulting process 分配一个物理页，复制原页面内容到新页面，将 PTE 指向这个新页面，并将 PTE 设置为 writable.</li><li>还没完！还有一些 free 相关的问题要解决。当一块物理页被多个进程使用时，我们不能随便 free，只有在最后一个使用这个页面的进程也不再使用时，我们才能 free. 解决办法是计数，类似 C++ 的智能指针。</li></ol><p>子进程内存页不真的分配，只创建一组映射。同时要记录好映射这组物理页的计数。修改 <code>uvmcopy</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">cow_uvmcopy</span><span class="params">(<span class="keyword">pagetable_t</span> old, <span class="keyword">pagetable_t</span> <span class="keyword">new</span>, uint64 sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = <span class="built_in">walk</span>(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    pa = <span class="built_in">PTE2PA</span>(*pte);</span><br><span class="line">    *pte = (*pte) &amp; (~PTE_W); <span class="comment">// mark as read-only</span></span><br><span class="line">    *pte = (*pte) | PTE_RSWD; <span class="comment">// low bit of RSW to represent COW</span></span><br><span class="line">    flags = <span class="built_in">PTE_FLAGS</span>(*pte);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">mappages</span>(<span class="keyword">new</span>, i, PGSIZE, (uint64)pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add_ref</span>(pa); <span class="comment">// add ref count. MIND that it is a criticial operation, so use lock.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  <span class="built_in">uvmunmap</span>(<span class="keyword">new</span>, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加一个结构体用于每个页面的引用计数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">refcounter</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="keyword">int</span> cnt;</span><br><span class="line">&#125;pageref[PHYSTOP / PGSIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_ref</span><span class="params">(uint64 pa, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  acquire(&amp;(pageref[pa / PGSIZE].lock));</span><br><span class="line">  pageref[pa / PGSIZE].cnt += x;</span><br><span class="line">  relese(&amp;(pageref[pa / PGSIZE].lock));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_ref</span><span class="params">(uint64 pa)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret;</span><br><span class="line">  acquire(&amp;(pageref[pa / PGSIZE].lock));</span><br><span class="line">  ret = pageref[pa / PGSIZE].cnt;</span><br><span class="line">  relese(&amp;(pageref[pa / PGSIZE].lock));</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_ref</span><span class="params">(uint64 pa)</span> </span>&#123;</span><br><span class="line">  acquire(&amp;(pageref[pa / PGSIZE].lock));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release_ref</span><span class="params">(uint64 pa)</span> </span>&#123;</span><br><span class="line">  release(&amp;(pageref[pa / PGSIZE].lock));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改 <code>kfree</code> 和 <code>kalloc</code>，与引用计数相关。只有 ref cnt = 1 才释放。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">kfree</span><span class="params">(<span class="keyword">void</span> *pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (get_ref((uint64)pa) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    add_ref((uint64)pa, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="keyword">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (struct run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">kalloc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)&#123;</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">    add_ref((uint64)r, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;utilities&quot;&gt;&lt;a href=&quot;#utilities&quot; class=&quot;headerlink&quot; title=&quot;utilities&quot;&gt;&lt;/a&gt;utilities&lt;/h1&gt;&lt;p&gt;用时 5h 左右.&lt;/p&gt;
&lt;h2 id=&quot;Boot-xv6&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="问道" scheme="https://eykenis.github.io/categories/%E9%97%AE%E9%81%93/"/>
    
    
    <category term="操作系统" scheme="https://eykenis.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>2022 EC-Final 现场赛 游记</title>
    <link href="https://eykenis.github.io/2023/03/29/2022ECFinal/"/>
    <id>https://eykenis.github.io/2023/03/29/2022ECFinal/</id>
    <published>2023-03-29T12:31:44.000Z</published>
    <updated>2023-04-12T14:19:55.124Z</updated>
    
    <content type="html"><![CDATA[<p>想了很久，还是不知道游记该如何动笔。</p><p>本来最近忙得焦头烂额，但是这之中日程好像排进了一个 EC Final，去比一下赛，<del>放松一下也未尝不可</del>。team 相信珂学的其他两人也都忙着面试、准备考研，所以大家这段时间实在是没什么训练，这场比赛确实只能是当作去旅游了。</p><p>无他，先记一下流水账。</p><h2 id="3-24"><a href="#3-24" class="headerlink" title="3.24"></a>3.24</h2><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230329145026467.png" alt="image-20230329145026467"></p><p>高铁站的麦当劳早餐，30块钱，旅行第一刀。这钱够我在学校吃一天了</p><p>下了高铁找到 sjie 他们，打算先去现场签到，但是他们先去酒店了。我们一支队就去现场签到。签到的时候拍了团体照，但是最后没有拿牌所以照片估计就这样看不到了。。。</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230329150125940.png" alt="image-20230329150125940"></p><blockquote><p>沪爷的学校装修就是好，如果不是非要报个 985，穿上孔乙己的长衫，让自己找工作时多一份筹码，我其实可以有这么多这么多好的选择。</p></blockquote><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/3E1169014E07D167FC620AD0850428D4.jpg" alt="img"></p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230329150432433.png" alt="image-20230329150432433"></p><p>目前手里没有合影，过段时间找其他拍了的人要要。。</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/A20A11EB8E6D1F4FF64C7664EA105816.jpg" alt="img"></p><p>热身赛。第一次现场赛，没有对比对象，但是印象还是比较好的。我们坐在厕所边上，所以<del>可以两分钟去一次厕所，每去一次回来写一行代码，上着上着就 AC 了</del>。</p><p>热身赛是两道纯签题，然后好像是一道图论题？我没有参加太多做法上的讨论，主要是另外两个队友在找共边最短路。热身赛我们是铜，但很显然一大堆队伍都没有认真打，明日之风直接来都不来了 QAQ，所以这也告诉我们，第二天打铁是再正常不过的事了（</p><p>中午去食堂吃饭但被告知这里只能用校园卡，参赛者只能用午餐券去特定食堂打饭。不过食堂阿姨和同学们也好说话，一个热情的小姐姐就帮我们队一块代点了餐。和后面晚餐券打的饭相比，还是自家学生的伙食好得多！而且肯定是比我学校的伙食强不少的。</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/2DE7C9602AAC01E3E8CCCFEBEB14DEF1.jpg" alt="img"></p><p>↑晚餐，感觉一般</p><p>热身赛结束，回去之后我们就回宾馆打音游和打牌了。</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230329151221015.png" alt="image-20230329151221015"></p><p>《关于我的队友是手柄音游大佬这件事》</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230329152821215.png" alt="image-20230329152821215"></p><p>打大富翁，从 7 点好像一直打到 1 点</p><p>（我都拍了些什么东西）</p><h2 id="3-25"><a href="#3-25" class="headerlink" title="3.25"></a>3.25</h2><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230329153127826.png" alt="image-20230329153127826"></p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/DFBFD1E17C11FF4048C1DCA9460B8C87.jpg" alt="img"></p><p>然后就是正式赛。压力还是挺大的。我们对面坐的是南邮一队，他们热身赛很轻松地A完三题直接走人，正式赛前这位也坐在我对面清体力。而且我看到了中间队长的 id，没错就是那个 cyx，蓝桥杯全国第一那位，草。把我们放在一堆志愿者的厕所边，让志愿者们看他们拿金，同时看我们打铁，实在是太不人道了！</p><p>我还是一如既往地不擅长快速出签到，但签到正好是我从后面开始读的 M 题，所以我看了眼榜马上丢给队友让他们快速出了。之后就是另一个换根 dp 的 J 题，交了很多发都没过，最后发现是因为多组输入 + <code>memset</code> 没换而 T 掉了，换手动初始化之后很快过。接下来便是坐牢时间。C、F、L 题多开，L 看错题以为又是个签到，没想到最后是一个如此奇怪又暴力的构造。C 题其实我们在开局两个多小时的时候已经出了思路，按数字低往高 DP 就可以了，还是因为训练停掉了的问题，中间出现了若干细节失误，因为没考虑 <code>10000000000 18</code> 这类情况，导致开了 <code>int128</code> 之后因为懒得写输出，最后又转回 <code>ull</code> 了，直接秒 WA，心态崩。找边界条件找很久之后终于发现了，但是这时候最傻逼了来了：我们竟然以为前文提到的边界情况会爆 <code>int128</code>！遂写字符串，果不其然写爆了。最后十分钟才会想起来这个根本不会爆，这种低级错误在其他人眼里妥妥的笑话好吧。赛后才知道我们也有机会开 I 题但榜歪了所以没有人去开。我看了 H 知道是一个暴搜但一直改 C 也没去写。于是打铁。</p><p>虽然没有训练，理所当然地打铁了，但是如果我们在这之前有去年下半年的状态，我觉得是不至于拿不到牌的。至少 C 题能出，I 题能读，F 也能想一想，甚至能玩一玩跳棋 H 和构造 L。可开的题很多，但太不熟练，留下了些许遗憾。</p><p>收拾心情，比赛结束后回酒店继续打牌（</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/2A574D96FC0239C26D9B2A7C6C4CD8F9.jpg" alt="img"></p><p>阿瓦隆是个好游戏，不过我智商太低，玩这个 cpu 很容易烧。</p><h2 id="3-26"><a href="#3-26" class="headerlink" title="3.26"></a>3.26</h2><p>25 号的阿瓦隆玩到凌晨1点，睡一觉起来吃个午饭就去闭幕式现场坐着了。于是在工作人员眼皮底下继续阿瓦隆（</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230329192524489.png" alt="image-20230329192524489"></p><p>原本这里在打牌的间隙，我们有一段对话我是想记下来的。但是当天晚上我就忘了一大段，到现在也没有想起来。只记得大概是这样</p><blockquote><p>“下次记得……”</p><p>“没有下次了啊”</p><p>“我们没有下次了，他还有”</p><p>“他还有挺多次的”</p><p>“我也没有下次了”</p></blockquote><p>这让我联想到《轻音少女》中，大家毕业前夕的对话。律也是这样提醒唯，没有下一次校园祭演出了。在座的有大四的，有即将要考研的。他们打完这场 final 或许就要退役了。</p><p>噢，好像想起来了，是说下次记得领牌子时不要去那么早，在那排队也是干等。（笑</p><p>我不禁想问自己，我还有下次吗？我不知道。或许下半年保研结束我会尝试再追一追自己过去没有达到过的成就。ACM 的时光是宝贵的。</p><p>又一次见到了杜老师本人及玉音放送！</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230329192613052.png" alt="image-20230329192613052"></p><p>偷一下一队的铜牌</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230329192634270.png" alt="image-20230329192634270"></p><p>重生之我是菜狗捧杯！蒋老师的时代来临力！</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/21239C237F7159B04D2ACF4D467A1280.jpg" alt="img"></p><p>闭幕式结束后去参加晚宴，因为我的一些问题，我们队没有报上晚宴，但是又必须要报了才能去（不太理解），所以最后我和 <font color="#0000ff">HennessyWithSoul</font> 是冒牌其他队的队员名字去的。事实证明有很多人没来，所以我们虽然来了但是现场还是有一些空位。</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/749F7AC8E108B39C715260778444CCA2.jpg" alt="img"></p><p>晚宴蒋老师就在对面桌！偷拍</p><p>晚宴的菜式就是一般的家常菜馆，就没有多拍（当然，白嫖是好的</p><p>晚上继续打牌。果然还是大家一起团建最有趣。这次打到2点多，有人要睡，也有人意犹未尽</p><p>顺便我想多玩玩好人，特别是平民，然后摆烂观摩 <font color="#ff0000"> Intercept </font>、<font color="#ff8c00"> nidhs </font>、<font color="#aa00aa"> ryougishikilove </font> 大脑对决。</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/4679492875E095486D7A7E10888F94BC.jpg" alt="img"></p><h2 id="3-27"><a href="#3-27" class="headerlink" title="3.27"></a>3.27</h2><p>因为睡太晚，今天直接中午起，下午我们去看《铃芽户缔》。总感觉新海诚太想复刻自己过去的成功，而不愿意做出新尝试了。画风依旧，配乐也依旧（不过好听好看是真的），但剧情我没看太懂。。前面两作可以算是爱情动漫，而这一步可以说和爱情毫无关系吧，不知道为啥最后非要强加一个女主喜欢上男主的情节，有点莫名其妙。如果去掉这个也只是勉强可以，或许是我没看太懂吧。可能以后欣赏不来这类电影了。</p><p>本来来上海是想在电玩城打 maimai 的，这次直接在电影院外面遇上了，不过因为大家的安排最后也没打成。一回宿舍就懒了，明明 maimai 离我那么近，现在好像又不知道要等到啥时候了。。</p><p>所以看完电影后我们是直接去了外滩。</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230329195107570.png" alt="image-20230329195107570"></p><p>可能比黄兴步行街宽一点的南京路步行街</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230329195113903.png" alt="image-20230329195113903"></p><p>晚六点准时鸣钟的万国建筑群</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230329195101756.png" alt="image-20230329195101756"></p><p>外滩，其实还有几张，不过就不放重复了的。ssjie 给我们拍了合照。</p><p>晚上我们8个人（廖爷 <font color ="#ff8c00">Lskkkno1</font> 去找高中同学了）没有协商好吃饭的位置，各想吃各的，所以分成两组4个人了，我们4个走了差不多一个小时的路去吃火锅了。路上、饭店里、回来的路上大家聊了很多对未来的展望，交流了很多很多。</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230329195917662.png" alt="image-20230329195917662"></p><p>（寿喜锅烧和牛蘸生鸡蛋还不错）</p><p>10点回酒店，继续打瓦。已经变成莫甘娜的形状了</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230329200226027.png" alt="image-20230329200226027"></p><h2 id="3-28"><a href="#3-28" class="headerlink" title="3.28"></a>3.28</h2><p>同样地，因为瓦太晚第二天起不来，大家起来时可以当场退房了。订的是晚上的火车，下午去KTV. 但大家都不是来唱歌的。大家都是来打瓦的！（其实我还是想唱会的）</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230329200355597.png" alt="image-20230329200355597"></p><p>五点多锁房后去初号机圣地巡礼</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/1ED3DC4395284C81EBC52361D56AD093.jpg" alt="img"></p><p>吃完晚饭，坐上火车，回家。</p><hr><p>这几天我都总觉得有很多想写下来的东西，但是回来之后真的开始打字，却发现写不出太多感想。或许自己该多读一些 paperback 了。或许下半年我还有机会去拼一拼更高的奖项，或许能看到校队里还能有新鲜血液。</p><p>EC Final 结束了。或许只是一次附带比赛和面基的旅游，但也藏着遗憾，和一些其他的什么情感。</p><p>  <font color="#ff8c00">      nidhs    </font>,    <font color="#0000ff">      Langdao_Zhang    </font>,    <font color="#ff8c00">      Sakuyalove    </font>,    <font color="#0000ff">      HennessyWithSoul    </font>,    <font color="#ff0000">      Intercept    </font>,    <font color="#aa00aa">      ryougishikilove    </font>, 似乎都不会/不能继续打下去了。这之后校队估计会冷清许多。</p>]]></content>
    
    
    <summary type="html">算法竞赛就像一个泡泡，外面是残酷的现实</summary>
    
    
    
    <category term="XCPC" scheme="https://eykenis.github.io/categories/XCPC/"/>
    
    
    <category term="XCPC" scheme="https://eykenis.github.io/tags/XCPC/"/>
    
  </entry>
  
  <entry>
    <title>MIT线性代数全笔记</title>
    <link href="https://eykenis.github.io/2023/03/22/MIT18-06-Linear-Algebra/"/>
    <id>https://eykenis.github.io/2023/03/22/MIT18-06-Linear-Algebra/</id>
    <published>2023-03-22T10:30:50.000Z</published>
    <updated>2023-06-24T07:45:18.700Z</updated>
    
    <content type="html"><![CDATA[<p>本文用于记录 MIT 18.06 课程关于线性代数的笔记.</p><h2 id="对线性方程组解的几何理解"><a href="#对线性方程组解的几何理解" class="headerlink" title="对线性方程组解的几何理解"></a>对线性方程组解的几何理解</h2><p>行空间:</p><p>在 $n$ 维空间内将线性方程组横向比较, 可以将每个方程看作一个 $n-1$ 维空间. 将他们在 $n$ 维空间内作图并求交，就可以得到解空间.</p><p>列空间:</p><p>例:</p><script type="math/tex; mode=display">x\begin{bmatrix}2\\-1\end{bmatrix}+y\begin{bmatrix}-1 \\ 2\end{bmatrix}=\begin{bmatrix}0 \\ 3\end{bmatrix}</script><p>将列向量 $(2,-1),(-1,2)$ 画到 $2$ 维平面上, 求出 $x,y$ 的值使得等式成立. 所有满足条件的 $x,y$ 即解向量.</p><h2 id="矩阵消元"><a href="#矩阵消元" class="headerlink" title="矩阵消元"></a>矩阵消元</h2><p>使用高斯消元法将矩阵消为 $U$ 矩阵. 再一步步回代.</p><p>变换矩阵：</p><p>对单位矩阵做初等变换, 再右乘以 $A$, 效果等同于直接对 $A$ 做相同变换.</p><blockquote><p>如果变换矩阵左乘以源矩阵会发生什么?</p><p>会从行变换变为列变换.</p><p>清楚初等变换的概念是分行和列的.</p></blockquote><p>消元变换时对一个单位矩阵作同样变换, 就可以得到一个消元的变换阵.</p><h2 id="矩阵乘法和逆"><a href="#矩阵乘法和逆" class="headerlink" title="矩阵乘法和逆"></a>矩阵乘法和逆</h2><p>分块矩阵：</p><p>只要矩阵分块形式是一致的 (分块后各个部分的分别相乘都合法), 就可以分块相乘.</p><p>逆矩阵：</p><script type="math/tex; mode=display">A^{-1}A=I</script><p>增广矩阵求法：原矩阵左/右接一个单位矩阵，对增广矩阵变换，使原矩阵部分变为单位矩阵，则之前拼接的单位矩阵就会变换为逆矩阵.</p><h2 id="LU-分解"><a href="#LU-分解" class="headerlink" title="LU 分解"></a>LU 分解</h2><p>因为</p><script type="math/tex; mode=display">A=LU</script><p>故求出 $L,U$ 其中一个后, 另一个可以用逆矩阵的方式求出, 因为</p><p>$EA=U\to ELU=E\to L=E^{-1}$</p><h2 id="转置，置换，向量空间"><a href="#转置，置换，向量空间" class="headerlink" title="转置，置换，向量空间"></a>转置，置换，向量空间</h2><p>一些基本性质</p><ul><li>$(AB)^{-1}=B^{-1}A^{-1}$</li><li>$(AB)^T=B^TA^T$</li><li>$(A^T)^{-1}=(A^{-1})^T$</li></ul><p>转置 (transpose) 矩阵是正交矩阵. 因为 $A^TA=I$. 感性上很好理解.</p><p>置换 (permutation) 矩阵, 顾名思义就是只进行行\列互换的初等变换矩阵.</p><p>向量空间的概念类似于群.<br><strong>定义：一个向量空间是由一些向量构成的非空集合。该集合上定义了加和数乘运算。满足运算封闭性。</strong></p><p>和群（特别地，向量空间是一类阿贝尔群）类似, 向量空间具有以下性质:</p><ul><li>运算封闭. 向量空间对 $+$, 数乘 两个运算封闭. (<strong>不包括叉乘！</strong>)</li><li>满足交换律. 对数乘满足结合律和分配律.</li><li>存在逆元. 在向量空间中为相反向量.</li><li>$\forall \vec x,1·{\vec x}=\vec x$</li></ul><p>子空间的概念类似于子群.</p><h2 id="列空间和零空间"><a href="#列空间和零空间" class="headerlink" title="列空间和零空间*"></a>列空间和零空间*</h2><p>列空间即由向量空间某些列构成的空间. 任何列空间一定是整个向量空间的子空间.</p><h3 id="零空间"><a href="#零空间" class="headerlink" title="零空间"></a>零空间</h3><p>零空间并不是指 $(0,…,0)$ 这个向量,</p><p><strong>而是指 $A\vec x=\vec 0$ 的所有解构成的解空间</strong>.</p><h2 id="主变量和特解"><a href="#主变量和特解" class="headerlink" title="主变量和特解"></a>主变量和特解</h2><p>先将一个矩阵进行消元，消元后主元的个数为该矩阵的<strong>秩</strong>。</p><p>在这个 $U$ 矩阵中，有主元的列称为<strong>主列</strong>，其余列为<strong>自由列</strong>。自由列的变量定值后可以解得矩阵的一个特解。</p><p>假设矩阵有 $n$ 个自由列，那么取 $n$ 个<strong>不线性相关</strong>的特解就可以表达出原方程组的通解。</p><h3 id="简化行阶梯形式"><a href="#简化行阶梯形式" class="headerlink" title="简化行阶梯形式"></a>简化行阶梯形式</h3><p>$U$ 在进行列变换（列交换）后可以变为行阶梯形式 $R=\begin{bmatrix}I&amp; F\\0 &amp; 0\end{bmatrix}$.</p><p>把主变量放在左边的列，自由变量放在右边的列。</p><p>然后就可以解出零空间。</p><p>$Rx=0\rarr N=\begin{bmatrix}-F\\I\end{bmatrix}$.</p><h2 id="Ax-b-的可解性与解的结构"><a href="#Ax-b-的可解性与解的结构" class="headerlink" title="$Ax=b$ 的可解性与解的结构"></a>$Ax=b$ 的可解性与解的结构</h2><h2 id="线性相关性、基、维数"><a href="#线性相关性、基、维数" class="headerlink" title="线性相关性、基、维数"></a>线性相关性、基、维数</h2><h3 id="线性相关"><a href="#线性相关" class="headerlink" title="线性相关"></a>线性相关</h3><p>向量组<strong>存在</strong>结果为零向量的组合则称<strong>线性相关</strong>（除开所有向量都数乘 0 的情况）</p><h3 id="张成"><a href="#张成" class="headerlink" title="张成"></a>张成</h3><p>指向量组的所有线性组合的结果生成的空间。</p><h3 id="基"><a href="#基" class="headerlink" title="基"></a>基</h3><p>向量基有以下特点：</p><ol><li>线性无关</li><li>能够生成整个空间</li></ol><p>根据第二个特点，可以知道向量基是和向量空间对应的概念。+</p><h3 id="维数"><a href="#维数" class="headerlink" title="维数"></a>维数</h3><p>基向量的个数，就是这个向量空间的维数。</p><p>而基向量组按列组成的矩阵，它的秩就等于这个向量空间的维数。也就是说矩阵的列空间维数=矩阵的秩。注意是<strong>数量上</strong>相等，这两个概念是不同的。</p><p>而矩阵的零空间的维数，等于矩阵自由变量的个数。因此 $free_variables=n-rank$.</p><h2 id="四个基本子空间"><a href="#四个基本子空间" class="headerlink" title="四个基本子空间"></a>四个基本子空间</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文用于记录 MIT 18.06 课程关于线性代数的笔记.&lt;/p&gt;
&lt;h2 id=&quot;对线性方程组解的几何理解&quot;&gt;&lt;a href=&quot;#对线性方程组解的几何理解&quot; class=&quot;headerlink&quot; title=&quot;对线性方程组解的几何理解&quot;&gt;&lt;/a&gt;对线性方程组解的几何理解&lt;</summary>
      
    
    
    
    <category term="问道" scheme="https://eykenis.github.io/categories/%E9%97%AE%E9%81%93/"/>
    
    
    <category term="数学" scheme="https://eykenis.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>《Effective C++》读书笔记（一）</title>
    <link href="https://eykenis.github.io/2023/03/01/EffectiveCPP/"/>
    <id>https://eykenis.github.io/2023/03/01/EffectiveCPP/</id>
    <published>2023-03-01T07:47:42.000Z</published>
    <updated>2023-03-20T07:02:12.782Z</updated>
    
    <content type="html"><![CDATA[<p>此文用于记录学习时的重点和 comments.</p><h1 id="Accounting-yourself-to-C"><a href="#Accounting-yourself-to-C" class="headerlink" title="Accounting yourself to C++"></a>Accounting yourself to C++</h1><h2 id="条款-1：视-C-为一个语言联邦"><a href="#条款-1：视-C-为一个语言联邦" class="headerlink" title="条款 1：视 C++ 为一个语言联邦"></a>条款 1：视 C++ 为一个语言联邦</h2><p>C++ 统共由四部分组成：</p><ul><li>C</li><li>Object</li><li>STL</li><li>template</li></ul><p>据我目前所知，STL 属于其中唯一一个通过封装形成的，官方的 STL 虽然够泛用了，但在特定场景可能有问题，因此也出现过一些优化版本，例如 EASTL.</p><h2 id="条款-2：使用-const-enum-inline-替换-define"><a href="#条款-2：使用-const-enum-inline-替换-define" class="headerlink" title="条款 2：使用 const, enum, inline 替换 #define"></a>条款 2：使用 const, enum, inline 替换 #define</h2><p>个人经常 #define 来处理变量, 看过很多别人的代码也是这样做的，用的多了，就会发现 define 的内容括号打好很重要，因为毕竟只是简单的文本替换，很容易出现优先级导致的语义错误，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson k &lt;&lt; 1</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line">cout &lt;&lt; lson &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>这样是会报错的.</p><p>当然该条目好像讨论的是全局变量赋值.</p><h3 id="define-和-const-enum-等的区别"><a href="#define-和-const-enum-等的区别" class="headerlink" title="define 和 const, enum 等的区别"></a>define 和 const, enum 等的区别</h3><p>让我们先来复习一下 CSAPP 中 C 语言生成程序的过程：</p><ul><li>预处理器</li><li>编译器</li><li>汇编器</li><li>链接器</li></ul><p><code>#define</code> 显然是在预处理阶段完成的，这一阶段所做的全部都是文本编辑，其中<code>#define</code>的所有宏定义被全部转换.</p><p>它的问题有啥呢？</p><ol><li><p>在程序链接过程中，<code>#define</code> 的内容早就被替换了，其所指代的符号自然不可能被添加到符号表中，因此如果这部分的内容出错了，是不会有提示的，单步调试观察变量也无法直接发现该处的问题.</p></li><li><p><strong>define 也可能导致内存滥用.</strong> 如果你使用 <code>#define</code> 定义常量，那么多个位置出现的该量虽然值相同，但在内存中可能使用了多份（它们没有名字，编译器没法负责任地把它们联系起来. 但使用 <code>const</code> 就不可能出现这个问题.</p></li></ol><h2 id="条款-3：尽可能使用-const"><a href="#条款-3：尽可能使用-const" class="headerlink" title="条款 3：尽可能使用 const"></a>条款 3：尽可能使用 const</h2><h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>让编译器替你找错误。</p><p>（除此以外，全局常量还可以节约一点空间. 它们<strong>可能</strong>不会被分配内存——有地址相关操作时，会分配只读内存给变量）</p><p>但是，const 有很多注意事项</p><hr><p>注意一下 const 指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* p = greeting;<span class="comment">// non-const pointer, const data</span></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p = greeting;<span class="comment">// const pointer, non-const data</span></span><br></pre></td></tr></table></figure><p>那么，<code>int const</code> 和 <code>const int</code> 有什么区别呢？</p><p><strong>没区别</strong></p><hr><p>迭代器的本质</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.<span class="built_in">begin</span>(); <span class="comment">//迭代器本质上是一个指针，而 const iterator&lt;T&gt; 相当于 T* const.</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果要指向一个 const 内容，则使用 const_iterator</span></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt;const_iterator cIter = vec.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure><hr><p>常被忽略的：<code>const</code> 修饰原函数返回值的函数，是可以重载的. 这不是只有返回值不同，而是对象不同，一个是普通 <code>class</code>，一个是 <code>const class</code>.</p><hr><p>关于 <code>func() const</code>，该 <code>const</code> 修饰该函数. 如果某个类的成员函数只有 <code>func()</code> 而没有 <code>func() const</code>，那么对于一个 <code>const class</code> 对象，调用 <code>func()</code> 就会出错. </p><p>这是因为函数的实际参数是有一个隐藏的 <code>this</code> 指针的，<code>func()</code> 中的 <code>this</code> 没有 <code>const</code> 修饰符，所以参数列表不匹配，就会报错. 而 <code>func() const</code> 传入的是 <code>const this</code> 指针，自然就可用了。</p><p>所以，<code>func() const</code> 中的 <code>const</code> 相当于修饰 <code>this</code> 指针。</p><hr><p>关于 <code>logical constness</code></p><p>使用 <code>mutable</code> 关键字，可以使得 <code>const</code> 类中的指定 <strong>non-static</strong> 变量可修改.</p><h2 id="条款-4：确定对象被使用前已经被初始化"><a href="#条款-4：确定对象被使用前已经被初始化" class="headerlink" title="条款 4：确定对象被使用前已经被初始化"></a>条款 4：确定对象被使用前已经被初始化</h2><p>内置类型需要自己留意，写手工初始化。</p><p>而 <code>class</code> 就得写构造函数了。但是很多书教初始化有两种写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #1</span></span><br><span class="line">A::<span class="built_in">A</span>(type p) &#123; x = p; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #2</span></span><br><span class="line">A::<span class="built_in">A</span>(type p) : <span class="built_in">x</span>(p) &#123; &#125;</span><br></pre></td></tr></table></figure><p>通常管第二种叫做列表初始化。</p><p>其实这<strong>不对</strong>！</p><p>第一种并不能叫做初始化，而是对未初始化的值进行赋值，第二个才算初始化。</p><h1 id="Constructors-Destructors-and-Assignment-Operators"><a href="#Constructors-Destructors-and-Assignment-Operators" class="headerlink" title="Constructors, Destructors, and Assignment Operators"></a>Constructors, Destructors, and Assignment Operators</h1><h2 id="条款-5：了解-C-默默编写并调用哪些函数"><a href="#条款-5：了解-C-默默编写并调用哪些函数" class="headerlink" title="条款 5：了解 C++ 默默编写并调用哪些函数"></a>条款 5：了解 C++ 默默编写并调用哪些函数</h2><p>如果你的 <code>class</code> 没有写/重载以下内容，编译器会隐式地自己编写：</p><ul><li><p>default 构造函数（只要写了任何形式的构造函数，该函数就不会被创建）</p></li><li><p>copy 构造函数</p></li><li>析构函数</li><li>赋值操作符 <code>=</code></li></ul><p>但，编译器不总是帮你写这些，只有在你没有写，且程序中用到它们时，才会创建。</p><p>除此之外，以下两种情况也不会创建 assignment 操作符重载：</p><ol><li><p>class 的成员变量不可以修改。例如 reference 和 const.</p></li><li><p>父类将 <code>operator =</code> 设置为 <code>private</code>，则子类不会创建。</p></li></ol><h2 id="条款-6：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款-6：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款 6：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款 6：若不想使用编译器自动生成的函数，就该明确拒绝</h2><p>编译器可能会自动生成条款 5 中的各种函数，要想拒绝自动生成，只需要将他们声明为 <code>private</code>.</p><p>这样还会有一个问题：成员函数和 <code>friend</code> 友元函数还是可以访问它们。那么，你只需要不定义，而是只给声明即可。这样链接器找不到定义，就会得到一个 linkage error.</p><p>如果你想让这个 linkage error 提前至编译错误，你可以专门写一个 base class，来将不想被使用的函数放入，再让工作的 class 继承它即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;此文用于记录学习时的重点和 comments.&lt;/p&gt;
&lt;h1 id=&quot;Accounting-yourself-to-C&quot;&gt;&lt;a href=&quot;#Accounting-yourself-to-C&quot; class=&quot;headerlink&quot; title=&quot;Accounting yo</summary>
      
    
    
    
    <category term="问道" scheme="https://eykenis.github.io/categories/%E9%97%AE%E9%81%93/"/>
    
    
    <category term="C++" scheme="https://eykenis.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>开始新的学习——GAMES202笔记</title>
    <link href="https://eykenis.github.io/2022/12/21/games202/"/>
    <id>https://eykenis.github.io/2022/12/21/games202/</id>
    <published>2022-12-21T05:42:15.000Z</published>
    <updated>2023-04-12T14:13:57.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lecture-02-Recap-of-CG-Basics"><a href="#Lecture-02-Recap-of-CG-Basics" class="headerlink" title="Lecture 02 Recap of CG Basics"></a>Lecture 02 Recap of CG Basics</h1><p>本章为一些关于GAMES101的复习内容。</p><h2 id="渲染管线再复习"><a href="#渲染管线再复习" class="headerlink" title="渲染管线再复习"></a>渲染管线再复习</h2><p>硬件管线流程：顶点处理——三角形处理——光栅化——片元处理——缓冲操作</p><p>顶点处理：确定各顶点在屏幕空间的位置</p><p>三角形处理：确定三角形，确定面片</p><p>光栅化：将三角形像素化</p><p>片元处理：计算着色</p><p>缓冲操作：控制输出，后期处理</p><h2 id="Lecture-03-Real-time-Shadows-1"><a href="#Lecture-03-Real-time-Shadows-1" class="headerlink" title="Lecture 03 Real-time Shadows 1"></a>Lecture 03 Real-time Shadows 1</h2><p>这章首先复习一下在 LearnOpenGL 学过的两 pass 阴影。</p><p><strong>传统阴影有两大问题：走样和自遮挡</strong>。</p><p>阴影缓冲的方式能很好地在其他物体上显示阴影，但并不能处理模型自己挡住自己所产生的阴影。如果要用这种方式合理地产生自阴影，就需要将原来的模型拆解，这样产生的渲染代价是平方倍数增长的。</p><p>其二是走样，阴影缓冲分辨率是有限的，在光源视角看到的单像素位置可能换个角度之后就不再在屏幕上只占一个像素，这就导致了走样，阴影锯齿。这样产生的锯齿在第二个 pass 还没法用抗锯齿技术消除。</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230103134423578.png" alt="image-20230103134423578"></p><p>又是微积分，在图形学还没有接触过太多数学公式的我雾了…</p><h3 id="不等式在-RTR-中的应用"><a href="#不等式在-RTR-中的应用" class="headerlink" title="不等式在 RTR 中的应用"></a>不等式在 RTR 中的应用</h3><p>因为图形学 “看起来是对的那么就是对的” 法则，这些不等式的正确食用方法应该是<strong>把它们当等式用</strong> (approximately equal) 。</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230103134614300.png" alt="image-20230103134614300"></p><p>例如，通过约等式拆分两个函数乘积的积分，可以大大简化运算，提高效率。（式子右边的分母是归一化常数，也即区间长度）</p><p>然后我们拿来简化 PBR 公式：</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230103135325307.png" alt="image-20230103135325307"></p><p>这个公式积分范围越小越准，可以认为等式右边算的是左边的平均值。</p><h3 id="PCSS-Percentage-closer-soft-shadows"><a href="#PCSS-Percentage-closer-soft-shadows" class="headerlink" title="PCSS - Percentage closer soft shadows"></a>PCSS - Percentage closer soft shadows</h3><p>Shadow Mapping 产生的是硬阴影——阴影边界棱角分明，只可能有锯齿。</p><p>而软阴影存在过渡。通过名字可以窥见，PCSS 的软阴影处理方法可能就是离物体越远阴影越透明？</p><p>首先我们需要一个工具——<strong>PCF</strong>.</p><h4 id="PCF-的做法（Percentage-Closer-Filtering）"><a href="#PCF-的做法（Percentage-Closer-Filtering）" class="headerlink" title="PCF 的做法（Percentage Closer Filtering）"></a>PCF 的做法（Percentage Closer Filtering）</h4><p>在 Shadow Map 上，对每个像素进行 Filtering，找其附近 N×N 的像素，创建一个 01 矩阵——比其深度大为 1，深度小为 0.</p><p>然后取一个平均值作为其可见性。根据该可见性决定该处阴影透明度，这样就能在阴影边缘处达到模糊的效果。</p><p>（但这种方法不能消除走样，只会让锯齿变为模糊的锯齿。</p><p>效果：</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20230104144641628.png" alt="image-20230104144641628"></p><p>当然暴力也可以解决问题，使用的均值矩阵越大，边缘就越模糊，锯齿也就越不明显。</p><p>该算法的开销也是成倍增长，非常慢。</p><h4 id="优化做法——PCSS"><a href="#优化做法——PCSS" class="headerlink" title="优化做法——PCSS"></a>优化做法——PCSS</h4><ul><li>先得到某个区域内的遮挡物平均深度.</li><li>通过深度决定 filter size（Penumbra esitmation）</li><li>PCF</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Lecture-02-Recap-of-CG-Basics&quot;&gt;&lt;a href=&quot;#Lecture-02-Recap-of-CG-Basics&quot; class=&quot;headerlink&quot; title=&quot;Lecture 02 Recap of CG Basics&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="问道" scheme="https://eykenis.github.io/categories/%E9%97%AE%E9%81%93/"/>
    
    
  </entry>
  
  <entry>
    <title>ICPC沈阳线上赛游记</title>
    <link href="https://eykenis.github.io/2022/11/06/47thShenyang/"/>
    <id>https://eykenis.github.io/2022/11/06/47thShenyang/</id>
    <published>2022-11-06T14:32:24.000Z</published>
    <updated>2022-11-07T02:39:36.436Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>究竟什么样的结局，才配得上这一路的颠沛流离？</em></p><p>​                                                            ——当然不是说我，是说 Deft</p></blockquote><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20221107100047734.png" alt="image-20221107100047734"></p><p>曾经想都不太敢想的成绩，今天（11 月 6 号）居然真的达到了。rank54/733，Ag. 如果 A 能调出来真的有可能 Au. 可惜没有沉住气放弃了（后话）。</p><p>9 点起床，看了两把 DRX vs T1，到 10 点多出去吃饭赶往 108. 坐了一会之后，也没想啥，就这样吧。第三年参加 XCPC 了，虽然第一年只是体验卡，第二年最后几乎没有认真训练光膀子上场，今年总算是认真训练了一次，但是半个多月若干次 vp 都铜了，也就对这次比赛不抱太大希望，当作自己的最后一舞，尽情<del>（随便）</del>玩玩吧。</p><p>发题面时看到 D 题题目名：DRX vs T1. 心想这肯定是几天前随便凑的个签到题。果不其然开了之后队友迅速 A 掉了。<br>然后是 C 题，我也没看，盯着 F 脑子里全是打铁，又想到了去年济南，好像一道过不去的坎。构造，构造，构造。但是对着这个构造题脑子里什么思路都没有。开始在草稿纸上乱画，手工打表，然后开始瞎构造，$n×m$ 的矩阵，先构造 $1×m$ 的，然后想一下能不能由此推出来。构造了一个 $1×m$ 的矩阵 $M$ 之后，先尝试性地把 $M$ 重复画了 $n$ 遍，发现答案竟然没有变化！这一构造的充分性已经有了，于是就考虑必要性。手算了各种 $n$，$m$ 值有没有答案后发现，在有答案的情况下这样构造是一定能出的。<br>现在还不是很有信心，和队友讨论思路后继续想构造方法，发现可以指考虑 pure，连续一段相同的数字内部才会发生 pure，而跨过这些之后就全部是 mixed. 推了一个模型，好像是个背包？发现知道答案存在后跑背包好像没啥用，否决掉，于是想了个没有证明的贪心。<br>光脚不怕穿鞋的，打铁就打铁吧，不怕翻车，反正从来就没有不翻过，直接上去写贪心，然后居然 1A，第 19 个过 F 题，我们的排名一度来到 rk22，当时激动得手都发抖了久久不能平静。</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20221107100126217.png" alt="image-20221107100126217"></p><p>队友去讨论 L 后我看了一会 A 和 I ，但有点集中不了注意力 和 zzj 交流 A 作法后觉得这不就是个 sb 题么。看到过题人不多于是等队友写 L 并推一下 A 的细节。<br>开场大概三个小时时终于把 L 调出来了，上机写 A。然而 A 看起来 sb ，实际也特别 sb，细节巨多不着手写根本发现不了。最后爆掉，没有考虑完各种区间覆盖的情况，终究还是码力不足。<br>虽然 C D F L 对我们来说或许足够但 A 题确实近在眼前。或许还是心气不够，没有继续向前的勇气，或者是满足了（确实也已经特别满足了），最后半小时在发现多个细节调爆后还是半放弃了。看了会榜分析会不会掉出银牌区，想了各种最坏的情况，当然都是杞人忧天。滚榜最终 rank 54，甚至是银中上。不过这里本次题目区分度不够是要背锅的（<br>这对我来说或许算是一个好的结果，然而我终究是个不想当将军的士兵，一直都不敢去想更高的目标。本以为今年又破铜烂铁了，没想到开局还挺顺利的，估计会是今年的最高 rank 了（……功利 flag 先）。直到昨天银牌都是我不太有信心的，却没想到居然是离我从来不敢想象的 Au 最近的一次。<br>对我来说，这是“选对赛区少打两年”，而对别人来说，或许是“题很好，区分度优秀，下次不要再出了”吧（笑う</p><p>题外话：写着写着就发现自己的随笔文笔是越来越差越来越只会流水账了hhh</p>]]></content>
    
    
    <summary type="html">“人这一生，是不太需要别人建议的。不经历过是不会明白的”</summary>
    
    
    
    
    <category term="XCPC" scheme="https://eykenis.github.io/tags/XCPC/"/>
    
  </entry>
  
  <entry>
    <title>近期 Div 1 及多校/VP题解</title>
    <link href="https://eykenis.github.io/2022/08/25/codeforces-div-1s/"/>
    <id>https://eykenis.github.io/2022/08/25/codeforces-div-1s/</id>
    <published>2022-08-25T11:02:07.000Z</published>
    <updated>2023-05-06T02:31:52.464Z</updated>
    
    <content type="html"><![CDATA[<p>第一要务是收心，不要去在意杂事，不担心以后，最后几个月专心做竞赛，不留下遗憾。</p><h1 id="8-25-8-26-Codeforces-Round-767-Div-1"><a href="#8-25-8-26-Codeforces-Round-767-Div-1" class="headerlink" title="8.25~8.26 Codeforces Round #767 (Div. 1)"></a>8.25~8.26 Codeforces Round #767 (Div. 1)</h1><h2 id="1628A-Meximum-Array"><a href="#1628A-Meximum-Array" class="headerlink" title="1628A Meximum Array"></a>1628A Meximum Array</h2><p>对每个位置分别选。要使得字典序最大，那么第一要务是保证当前选的 $MEX$ 尽可能大。然后，相同值之中，我们选最左的那个，以此来保证在选取 $MEX$ 相同的条件下，整个 $b$ 的长度尽可能长。</p><p>于是我们可以用一个队列按顺序存各个数出现的位置，模拟一下保证这两个条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson k &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson k &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, queue&lt;<span class="keyword">int</span>&gt;&gt; pos;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            pos[a[i]].<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> st = i;</span><br><span class="line">            <span class="keyword">int</span> mex = <span class="number">-1</span>;</span><br><span class="line">            <span class="comment">// 寻找 mex+1,直到没有.</span></span><br><span class="line">            <span class="keyword">while</span> (!pos[mex + <span class="number">1</span>].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pos[mex + <span class="number">1</span>].<span class="built_in">front</span>() &lt; st) &#123;</span><br><span class="line">                    pos[mex + <span class="number">1</span>].<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (pos[mex + <span class="number">1</span>].<span class="built_in">front</span>() &lt;= i) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!pos[mex + <span class="number">1</span>].<span class="built_in">empty</span>() &amp;&amp; pos[mex + <span class="number">1</span>].<span class="built_in">front</span>() &lt;= i) &#123;</span><br><span class="line">                        pos[mex + <span class="number">1</span>].<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    mex++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                i = pos[mex + <span class="number">1</span>].<span class="built_in">front</span>();</span><br><span class="line">                pos[mex + <span class="number">1</span>].<span class="built_in">pop</span>();</span><br><span class="line">                mex++;</span><br><span class="line">            &#125;</span><br><span class="line">            b.<span class="built_in">push_back</span>(mex + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; b.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            cout &lt;&lt; b[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1628B-Peculiar-Movie-Preferences"><a href="#1628B-Peculiar-Movie-Preferences" class="headerlink" title="1628B Peculiar Movie Preferences"></a>1628B Peculiar Movie Preferences</h2><p>水题，每个字符串的长度都小于等于 3，首先单一个字符串自己组成回文的情况先处理掉，然后剩下的情况字符串数量都 $\geq2$.</p><p>假设我们能够造出一个使用的字符串数量为 $x\geq2$ 的回文串，那么最左边和最右边是一定可以构造成一个回文串的。如果最左边最右边长度相等，那么他们拼起来肯定是回文；如果长度不等，一个是 2，一个是 3，那么最前面两个和最后面两个肯定也相等，总长度 5，还是可以构成回文。</p><p>所以只需要对每个串看前面存不存在与他构成回文的串就行啦，字符串哈希或者 <code>map</code> 即可过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson k &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson k &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="comment">// 17576 - 780.</span></span><br><span class="line">        <span class="comment">// 规模最多为 2？？？</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        map&lt;string, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        map&lt;string, <span class="keyword">int</span>&gt; mp32;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            string s;</span><br><span class="line">            cin &gt;&gt; s;</span><br><span class="line">            <span class="keyword">if</span> (flag) <span class="keyword">continue</span>;</span><br><span class="line">            mp[s]++;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">2</span> &amp;&amp; s[<span class="number">0</span>] == s[<span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">                <span class="keyword">if</span> (mp.<span class="built_in">count</span>(s) || mp32.<span class="built_in">count</span>(s)) &#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">3</span>) &#123;</span><br><span class="line">                string tmp;</span><br><span class="line">                tmp += s[<span class="number">1</span>];</span><br><span class="line">                tmp += s[<span class="number">2</span>];</span><br><span class="line">                <span class="built_in">reverse</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());</span><br><span class="line">                <span class="keyword">if</span> (mp.<span class="built_in">count</span>(tmp)) &#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp.<span class="built_in">clear</span>(); tmp += s[<span class="number">0</span>], tmp += s[<span class="number">1</span>];</span><br><span class="line">                mp32[tmp]++;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">                <span class="keyword">if</span> (mp.<span class="built_in">count</span>(s)) &#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; (flag ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1628C-Grid-Xor"><a href="#1628C-Grid-Xor" class="headerlink" title="1628C Grid Xor"></a>1628C Grid Xor</h2><p>纯构造题…尝试了构造各个位置异或次数为奇数的方法，和不同的组合来容斥求答案的思路，越弄越复杂，但是其实很简单就能够造出每个位置被异或一次的方法……</p><p>按各个位置的奇偶性分别去手画几下即可（国际象棋棋盘染色），奇偶性不同的位置是互不影响的。具体可以参考洛谷上的题解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson k &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson k &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> f1[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> f2[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> v[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">1000</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i + j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                f1[i][j] = <span class="number">1</span>, f2[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> f2[i][j] = <span class="number">1</span>, f1[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                cin &gt;&gt; a[i][j];</span><br><span class="line">                v[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!f1[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; v[i - <span class="number">1</span>][j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">1</span> &amp;&amp; v[i][j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; n &amp;&amp; v[i + <span class="number">1</span>][j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; n &amp;&amp; v[i][j + <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                v[i - <span class="number">1</span>][j] = v[i][j - <span class="number">1</span>] = v[i + <span class="number">1</span>][j] = v[i][j + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                ans ^= a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!f2[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; v[i - <span class="number">1</span>][j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">1</span> &amp;&amp; v[i][j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; n &amp;&amp; v[i + <span class="number">1</span>][j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; n &amp;&amp; v[i][j + <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                v[i - <span class="number">1</span>][j] = v[i][j - <span class="number">1</span>] = v[i + <span class="number">1</span>][j] = v[i][j + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                ans ^= a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1628D1-Game-on-Sum-Easy-Version"><a href="#1628D1-Game-on-Sum-Easy-Version" class="headerlink" title="1628D1 Game on Sum (Easy Version)"></a>1628D1 Game on Sum (Easy Version)</h2><p>由 $2000$ 数据范围很容易想到需要构造一个 $dp$ 状态。设 $dp_{i,j}$ 表示已经选择了 $i$ 个数字，其中 $j$ 次相加的答案。</p><p>但因为存在二元博弈，这个 $dp$ 既不是最大值也不是最小值。考虑单独的每一步：<br>如果 Alice 给的数较大，那么 Bob 将会选择减。但若 Alice 给的数小，那么 Bob 在次数还没加够时可以选择加。因为 Bob 是在 Alice 给数之后选的，他会将答案最小化。</p><p>所以有</p><script type="math/tex; mode=display">dp_{i,j}=\min\{dp_{i-1,j}-x,dp_{i-1,j-1}+x \}</script><p>那么 Alice 现在可以决定 $x$，她会使得答案尽可能大。在和不变的条件下让二者最小值最大，因为显然有 $dp_{i-1,j}\geq dp_{i-1,j-1}$，且差值一定不大于 $k$，所以我们可以选择一个值使得 $dp_{i-1,j}-x=dp_{i-1,j-1}+x=avr$，这样就是最优的选择。</p><p>所以转移方程为</p><script type="math/tex; mode=display">dp_{i,j}=\frac{dp_{i-1,j}+dp_{i-1,j-1}}{2}</script><p>但要注意有个边界条件是不同的，即 $i=j$ 时，因为 Bob 只能选择加，所以 Alice 会最大化答案为 $ik$.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson k &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson k &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            ans = (ans * x) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        x = (x * x) % mod;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fpow</span>(x, mod - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">int</span> i2 = <span class="built_in">inv</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m, k;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            dp[i][i] = i * k % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i][j] = ((dp[i - <span class="number">1</span>][j] + dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) * i2) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; dp[n][m] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1628D2-Game-on-Sum-Hard-Version"><a href="#1628D2-Game-on-Sum-Hard-Version" class="headerlink" title="1628D2 Game on Sum (Hard Version)"></a>1628D2 Game on Sum (Hard Version)</h2><p>范围扩大，由 D1 解法可知答案只与 $k$ 有关，故我们应该时可以找到一个公式的。</p><p>考虑各个 $dp$ 值对 $dp_{n,m}$ 的贡献，每个 $dp$ 值理应包括：</p><p>若干个 $dp_{1,1}$ 及其 $\frac{1}{2^x}$ 倍，若干个 $dp_{2,2}$ 及其 $\frac{1}{2^x}$ 倍……所有的 $dp$ 值都可以只通过 $dp_{i,i}$ 的贡献推出来。</p><p>那么 $dp_{i,i}$ 对 $dp_{n,m}$ 的贡献，每个来自 $dp_{i,i}$ 的分贡献一定是走的不同的路径，从 $dp_{i,i}$ 走到 $dp_{n,m}$，路径不同，长度相同，所以最后的分贡献值都一样。这是经典的走楼梯组合问题，走法为 $C_{n-i-1}^{m-i}$，每次都贡献了 $\frac{dp_{i,i}}{2^{n-i}}$. 全部求和即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson k &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson k &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="keyword">int</span> pi[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            ans = (ans * x) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        x = (x * x) % mod;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fpow</span>(x, mod - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    pi[<span class="number">0</span>] = pi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        pi[i] = (pi[i - <span class="number">1</span>] * i) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n ,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((pi[n] * <span class="built_in">inv</span>(pi[m]) % mod) * <span class="built_in">inv</span>(pi[n - m])) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">pre</span>(maxn - <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m, k;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; (<span class="built_in">inv</span>(<span class="built_in">fpow</span>(<span class="number">2</span>, n - <span class="number">1</span>)) * k) % mod &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == m) &#123;</span><br><span class="line">            cout &lt;&lt; m * k % mod &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">C</span>(n - i - <span class="number">1</span>, m - i);</span><br><span class="line">            <span class="keyword">int</span> y = <span class="built_in">fpow</span>(<span class="built_in">inv</span>(<span class="number">2</span>), n - i);</span><br><span class="line">            ans = (ans + (i * ((x * y) % mod)) % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans * k % mod &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-27-8-28-吉林省赛复现"><a href="#8-27-8-28-吉林省赛复现" class="headerlink" title="8.27~8.28 吉林省赛复现"></a>8.27~8.28 吉林省赛复现</h1><p>四天三个训练赛，多补补题吧。</p><h2 id="The-15th-Jilin-Provincial-Collegiate-Programming-Contest-I-Nim-Game"><a href="#The-15th-Jilin-Provincial-Collegiate-Programming-Contest-I-Nim-Game" class="headerlink" title="The 15th Jilin Provincial Collegiate Programming Contest I. Nim Game"></a>The 15th Jilin Provincial Collegiate Programming Contest I. Nim Game</h2><p>复习 Nim 博弈，其条件是集合各数异或和为 0 即必败，否则必胜。</p><p>那么嘉然小姐想要赢，必定是集合中存在一个子集，其异或和为 0.</p><p>我们可以用线性基来判断。每次将一个数加入线性基，如果加入时更新了 $a_0$，说明现在有异或和为 0 且非空的子集了。又因为位数不会超过 $32$，所以当至少有 $32$ 个数时，线性基一定会更新到 $a_0$，一定存在一个异或和为 0 的子集，不用判断。小于 $32$ 的暴力判断即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson k &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson k &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, sum, tag;</span><br><span class="line">&#125;a[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> num[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    a[k].sum = a[lson].sum + a[rson].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    a[k].l = l, a[k].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        a[k].l = l, a[k].r = r;</span><br><span class="line">        a[k].sum = num[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(lson, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(rson, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!a[k].tag) <span class="keyword">return</span>;</span><br><span class="line">    a[lson].sum += a[k].tag * (a[lson].r - a[lson].l + <span class="number">1</span>);</span><br><span class="line">    a[lson].tag += a[k].tag;</span><br><span class="line">    a[rson].sum += a[k].tag * (a[rson].r - a[rson].l + <span class="number">1</span>);</span><br><span class="line">    a[rson].tag += a[k].tag;</span><br><span class="line">    a[k].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[k].l &gt; r || a[k].r &lt; l) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[k].l &gt;= l &amp;&amp; a[k].r &lt;= r) &#123;</span><br><span class="line">        a[k].sum += x * (a[k].r - a[k].l + <span class="number">1</span>);</span><br><span class="line">        a[k].tag += x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="built_in">add</span>(lson, l, r, x);</span><br><span class="line">    <span class="built_in">add</span>(rson, l, r, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">33</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">32</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(x &amp; (<span class="number">1</span> &lt;&lt; i))) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!b[i]) &#123;</span><br><span class="line">            b[i] = x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x ^= b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[k].l &gt; x || a[k].r &lt; x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[k].l == a[k].r &amp;&amp; a[k].l == x) <span class="keyword">return</span> a[k].sum;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(lson, x) + <span class="built_in">query</span>(rson, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; num[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, l, r, x;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(<span class="number">1</span>, l, r, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (r - l + <span class="number">1</span> &gt;= <span class="number">33</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(b));</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">                    <span class="keyword">int</span> y = <span class="built_in">query</span>(<span class="number">1</span>, i);</span><br><span class="line">                    y = <span class="built_in">insert</span>(y);</span><br><span class="line">                    <span class="keyword">if</span> (!y) &#123;</span><br><span class="line">                        flag = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; (flag ? <span class="string">&quot;No&quot;</span> : <span class="string">&quot;Yes&quot;</span>) &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-29-8-30-Educational-Codeforces-Round-134"><a href="#8-29-8-30-Educational-Codeforces-Round-134" class="headerlink" title="8.29~8.30 Educational Codeforces Round 134"></a>8.29~8.30 Educational Codeforces Round 134</h1><h2 id="1721D-Maximum-AND"><a href="#1721D-Maximum-AND" class="headerlink" title="1721D Maximum AND"></a>1721D Maximum AND</h2><p>贪心，优先保证高位能异或为 1.</p><p>为了 $a,b$ 异或为1，我们将 $a,b$ 分组。假设现在考虑到了第 $i$ 位，那么 $a$ 中第 $i$ 位为 1 的和 $b$ 中第 $i$ 位为 0 的分一组，反之亦然。如果分完组后，$a_i=1$ 和 $b_i=0$ 的数个数是相同的，说明这个分组是有效的，不会出现多余的数，于是我们分组继续下去就可以。如果出现了分不齐的情况，就说明在保证某几个高位能够达到 $1$ 的条件下，我们是无法保证这一位为 1 的，所以不进行分组，直接判断下一位。</p><p>（场上没有注意将大小为 0 的分组剔除，导致 vector 爆了，还不知道错在哪）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> xx;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pvv</span> &#123;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; a, b;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;pvv&gt; v, tmp;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        xx = <span class="number">0x7fffffff</span>;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; a, b;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            a.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            b.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        v.<span class="built_in">push_back</span>(&#123;a, b&#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">30</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            tmp.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                pvv a0b1, a1b0;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; v[i].a.<span class="built_in">size</span>(); ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v[i].a[k] &amp; (<span class="number">1</span> &lt;&lt; j)) a1b0.a.<span class="built_in">push_back</span>(v[i].a[k]);</span><br><span class="line">                    <span class="keyword">else</span> a0b1.a.<span class="built_in">push_back</span>(v[i].a[k]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; v[i].b.<span class="built_in">size</span>(); ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v[i].b[k] &amp; (<span class="number">1</span> &lt;&lt; j)) a0b1.b.<span class="built_in">push_back</span>(v[i].b[k]);</span><br><span class="line">                    <span class="keyword">else</span> a1b0.b.<span class="built_in">push_back</span>(v[i].b[k]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a0b1.a.<span class="built_in">size</span>() == a0b1.b.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!a0b1.a.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                        tmp.<span class="built_in">push_back</span>(a0b1);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!a1b0.a.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                        tmp.<span class="built_in">push_back</span>(a1b0);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    xx -= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">                v = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; xx &lt;&lt; endl;</span><br><span class="line">        v.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-31-9-1-Codeforces-Round-698-Div-1"><a href="#8-31-9-1-Codeforces-Round-698-Div-1" class="headerlink" title="8.31~9.1 Codeforces Round #698 (Div. 1)"></a>8.31~9.1 Codeforces Round #698 (Div. 1)</h1><h2 id="A-Nezzar-and-Board"><a href="#A-Nezzar-and-Board" class="headerlink" title="A. Nezzar and Board"></a>A. Nezzar and Board</h2><p>把所有的数放在数轴上，可以发现任取两个数，通过不断地往集合中加 $2x-y$，最后得到的数的间隔不会大于 $|x-y|$.</p><p>所以通过这两个数能构造出所有以 $x$ 或者 $y$ 为某项，公差为 $\gcd(x,y)$ 的等差数列。</p><p>扩展到所有元素可知，所有元素构造出来的应该是以某个 $a_i$ 为首项，公差为 $\gcd(a_1,a_2,…,a_n)$ 的等差数列。</p><p>先求出 $g=\gcd(a_1,a_2,…,a_n)$，然后枚举各个 $a_i$，看是否 $(k-a_i)\%g=0$.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #pragma GCC optimize(3)</span></span><br><span class="line"><span class="comment">// #define endl &#x27;\n&#x27;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson k &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson k &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="comment">// k = 2x - y</span></span><br><span class="line">        <span class="comment">// 2(x1a1 + x2a2 + ... + xnan) - (y1a1 + y2a2 + ...)</span></span><br><span class="line">        <span class="comment">// = (2x1 - y1)a1 + (2x2 - y2)a2 + ...</span></span><br><span class="line">        <span class="comment">// x + d = k --&gt; d = m * |x - y|.</span></span><br><span class="line">        <span class="comment">// k - x = d = m * |x - y|</span></span><br><span class="line">        <span class="comment">// (k - x) % |x - y| = 0</span></span><br><span class="line">        <span class="comment">// x, y 从集合中任取。</span></span><br><span class="line">        <span class="comment">// 存在整数列使得 k - ax = x1(a1 - a2) + x2(a2 - a3) + ... + x_&#123;n-1&#125;(a_&#123;n-1&#125; - an)</span></span><br><span class="line">        <span class="comment">// xi \in integer</span></span><br><span class="line">        <span class="comment">// 存在互质的数时一定yes... --&gt; gcd = 1</span></span><br><span class="line">        <span class="keyword">int</span> n, k;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> g = a[<span class="number">2</span>] - a[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            g = __gcd(a[i] - a[i - <span class="number">1</span>], g);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((k - a[i]) % g == <span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; (flag ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Nezzar-and-Binary-String"><a href="#B-Nezzar-and-Binary-String" class="headerlink" title="B. Nezzar and Binary String"></a>B. Nezzar and Binary String</h2><p>意外的简单题，但是卡壳了一会。</p><p>只要逆向考虑就能发现，因为每次操作都是要求 <strong>strictly less</strong> than half of the characters，所以其实倒过来的修改是固定，没有选择的。一开始没注意严格更少，还想了一会二者相等的情况。。</p><p>所以逆向考虑，操作用线段树维护即可，遇到数量相等的情况直接 <code>break</code> 输出 $NO$，最后 $n\log n$ 判断一下最终得到的字符串，再比较一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #pragma GCC optimize(3)</span></span><br><span class="line"><span class="comment">// #define endl &#x27;\n&#x27;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson k &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson k &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> ql[maxn], qr[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> cnt0, cnt1;</span><br><span class="line">    <span class="keyword">int</span> tag;</span><br><span class="line">&#125;a[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line">string s, f;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    a[k].cnt0 = a[lson].cnt0 +a[rson].cnt0;</span><br><span class="line">    a[k].cnt1 = a[lson].cnt1 + a[rson].cnt1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    a[k].l = l, a[k].r = r;</span><br><span class="line">    a[k].tag = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[l] == <span class="string">&#x27;0&#x27;</span>) a[k].cnt0 = <span class="number">1</span>, a[k].cnt1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> a[k].cnt1 = <span class="number">1</span>, a[k].cnt0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(lson, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(rson, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[k].tag == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    a[lson].cnt0 = (a[lson].r - a[lson].l + <span class="number">1</span>) * (!a[k].tag);</span><br><span class="line">    a[rson].cnt0 = (a[rson].r - a[rson].l + <span class="number">1</span>) * (!a[k].tag);</span><br><span class="line">    a[lson].cnt1 = (a[lson].r - a[lson].l + <span class="number">1</span>) * a[k].tag;</span><br><span class="line">    a[rson].cnt1 = (a[rson].r - a[rson].l + <span class="number">1</span>) * a[k].tag;</span><br><span class="line">    a[lson].tag = a[rson].tag = a[k].tag;</span><br><span class="line">    a[k].tag = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[k].l &gt; r || a[k].r &lt; l) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[k].l &gt;= l &amp;&amp; a[k].r &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x) &#123;</span><br><span class="line">            a[k].tag = <span class="number">1</span>;</span><br><span class="line">            a[k].cnt1 = a[k].r - a[k].l + <span class="number">1</span>;</span><br><span class="line">            a[k].cnt0 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            a[k].tag = <span class="number">0</span>;</span><br><span class="line">            a[k].cnt0 = a[k].r - a[k].l + <span class="number">1</span>;</span><br><span class="line">            a[k].cnt1 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="built_in">change</span>(lson, l, r, x);</span><br><span class="line">    <span class="built_in">change</span>(rson, l, r, x);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query0</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[k].l  &gt; r || a[k].r &lt; l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[k].l &gt;= l &amp;&amp; a[k].r &lt;= r) <span class="keyword">return</span> a[k].cnt0;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query0</span>(lson, l, r) + <span class="built_in">query0</span>(rson, l, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query1</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[k].l  &gt; r || a[k].r &lt; l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[k].l &gt;= l &amp;&amp; a[k].r &lt;= r) <span class="keyword">return</span> a[k].cnt1;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query1</span>(lson, l, r) + <span class="built_in">query1</span>(rson, l, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, q;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; f;</span><br><span class="line">        s = <span class="string">&#x27;X&#x27;</span> + s, f = <span class="string">&#x27;X&#x27;</span> + f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; ql[i] &gt;&gt; qr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = q; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt0 = <span class="built_in">query0</span>(<span class="number">1</span>, ql[i], qr[i]);</span><br><span class="line">            <span class="keyword">int</span> cnt1 =  <span class="built_in">query1</span>(<span class="number">1</span>, ql[i], qr[i]);</span><br><span class="line">            <span class="keyword">if</span> (cnt0 == <span class="number">0</span> || cnt1 == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (cnt0 == cnt1) &#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cnt0 &lt; cnt1) &#123;</span><br><span class="line">                <span class="built_in">change</span>(<span class="number">1</span>, ql[i], qr[i], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">change</span>(<span class="number">1</span>, ql[i], qr[i], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        string x;</span><br><span class="line">        x += <span class="string">&quot;X&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = <span class="built_in">query0</span>(<span class="number">1</span>, i, i);</span><br><span class="line">            <span class="keyword">if</span> (c) x += <span class="string">&quot;0&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> x += <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x != s) flag = <span class="number">0</span>;</span><br><span class="line">        cout &lt;&lt; (flag ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Nezzar-and-Nice-Beatmap"><a href="#C-Nezzar-and-Nice-Beatmap" class="headerlink" title="C. Nezzar and Nice Beatmap"></a>C. Nezzar and Nice Beatmap</h2><p>我还手画有没有不可能的情况呢，一直画不出来。</p><p>结果题解给了一个非常简洁优雅的方法：每次选取未加入点中距离最远的点连起来。</p><p>于是就保证每个角都是锐角……太强了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #pragma GCC optimize(3)</span></span><br><span class="line"><span class="comment">// #define endl &#x27;\n&#x27;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson k &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson k &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(point p1, point p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;point&gt; v1, v2;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        v1.<span class="built_in">clear</span>();</span><br><span class="line">        v1.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; v1[i].x &gt;&gt; v1[i].y;</span><br><span class="line">            v1[i].id = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; v1[<span class="number">0</span>].id &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            v2 = v1;</span><br><span class="line">            <span class="keyword">int</span> mxi = <span class="number">1</span>, mxd = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (v1.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v2.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> d = <span class="built_in">dis</span>(v2[<span class="number">0</span>], v2[i]);</span><br><span class="line">                <span class="keyword">if</span> (d &gt; mxd) &#123;</span><br><span class="line">                    mxi = i, mxd = d;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            v1.<span class="built_in">clear</span>();</span><br><span class="line">            v1.<span class="built_in">push_back</span>(v2[mxi]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v2.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == mxi) <span class="keyword">continue</span>;</span><br><span class="line">                v1.<span class="built_in">push_back</span>(v2[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2022“杭电杯”中国大学生算法设计超级联赛（9）1008-Shortest-Path-in-GCD-Graph"><a href="#2022“杭电杯”中国大学生算法设计超级联赛（9）1008-Shortest-Path-in-GCD-Graph" class="headerlink" title="2022“杭电杯”中国大学生算法设计超级联赛（9）1008 Shortest Path in GCD Graph"></a>2022“杭电杯”中国大学生算法设计超级联赛（9）1008 Shortest Path in GCD Graph</h2><ol><li><p>任何两点间的距离都不大于 $2$，因为 $\gcd(1,i)=1$. 故答案只能是 $1$ 或者 $2$.</p></li><li><p>对于 $a,b$ 的距离，若 $\gcd(a,b)&gt;1$，问题等价于找到满足 $\gcd(a,i)=1,\gcd(b,j)=1$ 的 $i,j$ 数量。</p></li><li>对于 $n\leq10^7$ 条件，任何数的素因子数量都不会超过 $15$ 个（大概 $12$ 个左右）。可以先筛出 $a$ 和 $b$ 的所有素因子，然后计算它们在 $[1,n]$ 内整除的数，再用总数减去即可。</li><li>要求 $a,b$ 的素因子在 $[1,n]$ 内整除的数。假设素因子是 $\{x_1,x_2,…,x_m\}$，例如 $x_1$ 在范围内的倍数有 $\lfloor \frac{n}{x_1} \rfloor$ 个，然后再算 $x_2,x_3,…$ 的，这里 $x_1,x_2$ 的倍数肯定有重合的部分，发现这是一个容斥模型，于是可以二进制枚举容斥，这样单次询问复杂度上限就是 $O(2^{12})$.</li></ol><p><strong>std 的容斥模板是好的（</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="comment">// #define endl &#x27;\n&#x27;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> st[maxn], primes[maxn / <span class="number">10</span>], f[maxn];</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ola</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[i] == <span class="number">0</span>) primes[++cnt] = i, f[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; primes[j] &lt;= n / i; ++j) &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="number">1</span>;</span><br><span class="line">            f[primes[j] * i] = primes[j];</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">set&lt;<span class="keyword">int</span>&gt; myset;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = f[x];</span><br><span class="line">        myset.<span class="built_in">insert</span>(y);</span><br><span class="line">        <span class="keyword">while</span> (x % y == <span class="number">0</span>) x /= y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> s, <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s &gt; n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == vec.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        ans += o * (n / s);</span><br><span class="line">        <span class="comment">// ans = (ans + mod) % mod;</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(x + <span class="number">1</span>, s, o);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可写成乘法. 因为取个数就是要向下取整，不能不舍去.</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt;= n / vec[x]) <span class="built_in">dfs</span>(x + <span class="number">1</span>, s * vec[x], -o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    myset.<span class="built_in">clear</span>(); vec.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">add</span>(x), <span class="built_in">add</span>(y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;xx : myset) vec.<span class="built_in">push_back</span>(xx);</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// freopen(&quot;1008.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;1008.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line">    t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">        <span class="built_in">ola</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v;</span><br><span class="line">            cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">            <span class="keyword">if</span> (__gcd(u, v) == <span class="number">1</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;1 1&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">solve</span>(u, v);</span><br><span class="line">            <span class="keyword">if</span> (__gcd(u, v) == <span class="number">2</span>) ans++;</span><br><span class="line">            cout &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-2-9-15"><a href="#9-2-9-15" class="headerlink" title="9.2~9.15"></a>9.2~9.15</h1><p>记忆丢失……这段时间补的题懒，没写题解</p><p>（其实是因为没 vp div. 1）</p><h2 id="CCPC网络赛-H-Multiple-Set"><a href="#CCPC网络赛-H-Multiple-Set" class="headerlink" title="CCPC网络赛 H. Multiple Set"></a>CCPC网络赛 H. Multiple Set</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #pragma GCC optimize(3)</span></span><br><span class="line"><span class="comment">// #define endl &#x27;\n&#x27;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int __int128</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> L, R, K;</span><br><span class="line"><span class="keyword">int</span> st[N], primes[N / <span class="number">4</span>], f[N], cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ola</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[i] == <span class="number">0</span>) primes[cnt++] = i, f[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; ++j) &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="number">1</span>;</span><br><span class="line">            f[primes[j] * i] = i;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">set&lt;<span class="keyword">int</span>&gt; fac;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">bool</span> vis[N / <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fj</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    fac.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; primes[i]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (x % primes[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            fac.<span class="built_in">insert</span>(primes[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (x % primes[i] == <span class="number">0</span>) x /= primes[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) fac.<span class="built_in">insert</span>(x);</span><br><span class="line">    vec.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : fac) &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            ans = ans * x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans &gt; K) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        x = x * x;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> prod, <span class="keyword">int</span> n, <span class="keyword">int</span> lp, <span class="keyword">bool</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = (L / prod) + (L % prod &gt; <span class="number">0</span>), r = R / prod;</span><br><span class="line">    <span class="keyword">int</span> fp = <span class="built_in">fpow</span>(<span class="number">2</span>, r - l);</span><br><span class="line">    <span class="keyword">if</span> (fp &gt; <span class="number">0</span> &amp;&amp; z &amp;&amp; K == fp * (l + r) * (r - l + <span class="number">1</span>) * prod / <span class="number">2</span>) ans++, res.<span class="built_in">push_back</span>(prod);</span><br><span class="line">    <span class="keyword">if</span> (lp &gt;= vec.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(prod, n, lp + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; prod * vec[lp] &lt;= K; ++i) &#123;</span><br><span class="line">        prod *= vec[lp];</span><br><span class="line">        <span class="built_in">dfs</span>(prod, n + <span class="number">1</span>, lp + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">signed</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="built_in">ola</span>(<span class="number">1e7</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> LL, RR, KK;</span><br><span class="line">        cin &gt;&gt; LL &gt;&gt; RR &gt;&gt; KK;</span><br><span class="line">        L = LL, R = RR, K = KK;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fj</span>(K);</span><br><span class="line">        res.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No Solution&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (res.<span class="built_in">size</span>() &gt; <span class="number">1e5</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Too Many!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; (<span class="keyword">long</span> <span class="keyword">long</span>)ans &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : res) cout &lt;&lt; (<span class="keyword">long</span> <span class="keyword">long</span>)x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-16-9-17"><a href="#9-16-9-17" class="headerlink" title="9.16~9.17"></a>9.16~9.17</h1><h2 id="【模板】普通平衡树（数据加强版）-（替罪羊树实现）"><a href="#【模板】普通平衡树（数据加强版）-（替罪羊树实现）" class="headerlink" title="【模板】普通平衡树（数据加强版） （替罪羊树实现）"></a>【模板】普通平衡树（数据加强版） （替罪羊树实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> alpha = <span class="number">0.7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> ch[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="keyword">int</span> sz;</span><br><span class="line">&#125;tree[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">tree[x].sz = tree[tree[x].ch[<span class="number">0</span>]].sz + tree[tree[x].ch[<span class="number">1</span>]].sz + tree[x].cnt;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; fp, fn, fv;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flat</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tree[p].ch[<span class="number">0</span>]) &#123;</span><br><span class="line"><span class="built_in">flat</span>(tree[p].ch[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> id = fp.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (tree[p].cnt) &#123;</span><br><span class="line">fp.<span class="built_in">push_back</span>(p);</span><br><span class="line">fv.<span class="built_in">push_back</span>(tree[p].val);</span><br><span class="line">fn.<span class="built_in">push_back</span>(tree[p].cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tree[p].ch[<span class="number">1</span>]) &#123;</span><br><span class="line"><span class="built_in">flat</span>(tree[p].ch[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rebuild</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = fp.size() - <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (l &lt; mid) &#123;</span><br><span class="line">tree[p].ch[<span class="number">0</span>] = fp[(l + mid - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>];</span><br><span class="line"><span class="built_in">rebuild</span>(tree[p].ch[<span class="number">0</span>], l, mid - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> tree[p].ch[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (mid &lt; r) &#123;</span><br><span class="line">tree[p].ch[<span class="number">1</span>] = fp[(mid + <span class="number">1</span> + r) &gt;&gt; <span class="number">1</span>];</span><br><span class="line"><span class="built_in">rebuild</span>(tree[p].ch[<span class="number">1</span>], mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> tree[p].ch[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">tree[p].cnt = fn[mid];</span><br><span class="line">tree[p].val = fv[mid];</span><br><span class="line"><span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_and_rebuild</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="built_in">pushup</span>(p);</span><br><span class="line"><span class="keyword">double</span> lchp = <span class="number">1.</span> * tree[tree[p].ch[<span class="number">0</span>]].sz / tree[p].sz;</span><br><span class="line"><span class="keyword">if</span> (lchp &gt; alpha || lchp &lt; <span class="number">1</span> - alpha) &#123;</span><br><span class="line">fp.<span class="built_in">clear</span>(), fv.<span class="built_in">clear</span>(), fn.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">int</span> id = <span class="built_in">flat</span>(p);</span><br><span class="line"><span class="built_in">swap</span>(fp[id], fp[(fp.<span class="built_in">size</span>() - <span class="number">1</span>) / <span class="number">2</span>]);</span><br><span class="line"><span class="built_in">rebuild</span>(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> __insert(<span class="keyword">int</span> x, <span class="keyword">int</span> p, <span class="keyword">int</span> f, <span class="keyword">bool</span> which) &#123;</span><br><span class="line"><span class="keyword">if</span> (!p) &#123;</span><br><span class="line">p = tree[f].ch[which] = ++cnt;</span><br><span class="line">tree[p].val = x;</span><br><span class="line">tree[p].sz = tree[p].cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">check_and_rebuild</span>(p);</span><br><span class="line"><span class="keyword">if</span> (x == tree[p].val) &#123;</span><br><span class="line">tree[p].cnt++;</span><br><span class="line">tree[p].sz++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x &lt; tree[p].val) &#123;</span><br><span class="line">__insert(x, tree[p].ch[<span class="number">0</span>], p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x &gt; tree[p].val) &#123;</span><br><span class="line">__insert(x, tree[p].ch[<span class="number">1</span>], p, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!cnt) &#123;</span><br><span class="line">tree[++cnt].cnt = <span class="number">1</span>;</span><br><span class="line">tree[cnt].val = x;</span><br><span class="line">tree[cnt].sz = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">__insert(x, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> __remove(<span class="keyword">int</span> x, <span class="keyword">int</span> p, <span class="keyword">int</span> f, <span class="keyword">bool</span> which) &#123;</span><br><span class="line"><span class="built_in">check_and_rebuild</span>(p);</span><br><span class="line"><span class="keyword">if</span> (x &lt; tree[p].val) &#123;</span><br><span class="line">__remove(x, tree[p].ch[<span class="number">0</span>], p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x &gt; tree[p].val) &#123;</span><br><span class="line">__remove(x, tree[p].ch[<span class="number">1</span>], p, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">tree[p].cnt--;</span><br><span class="line">tree[p].sz--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="comment">// guarantee it exists</span></span><br><span class="line"><span class="keyword">if</span> (tree[<span class="number">1</span>].val == x) &#123;</span><br><span class="line">tree[<span class="number">1</span>].cnt--;</span><br><span class="line">tree[<span class="number">1</span>].sz--;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">__remove(x, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countl</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; tree[p].val) &#123;</span><br><span class="line"><span class="keyword">return</span> tree[p].ch[<span class="number">0</span>] ? <span class="built_in">countl</span>(x, tree[p].ch[<span class="number">0</span>]) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x &gt; tree[p].val) <span class="keyword">return</span> tree[tree[p].ch[<span class="number">0</span>]].sz + tree[p].cnt + (tree[p].ch[<span class="number">1</span>] ? <span class="built_in">countl</span>(x, tree[p].ch[<span class="number">1</span>]) : <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> tree[tree[p].ch[<span class="number">0</span>]].sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countg</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt; tree[p].val) &#123;</span><br><span class="line"><span class="keyword">return</span> tree[p].ch[<span class="number">1</span>] ? <span class="built_in">countg</span>(x, tree[p].ch[<span class="number">1</span>]) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x &lt; tree[p].val) <span class="keyword">return</span> tree[tree[p].ch[<span class="number">1</span>]].sz + tree[p].cnt + (tree[p].ch[<span class="number">0</span>] ? <span class="built_in">countg</span>(x, tree[p].ch[<span class="number">0</span>]) : <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> tree[tree[p].ch[<span class="number">1</span>]].sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rk</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">countl</span>(x, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> __kth(<span class="keyword">int</span> k, <span class="keyword">int</span> p) &#123;</span><br><span class="line"><span class="keyword">if</span> (tree[tree[p].ch[<span class="number">0</span>]].sz &gt;= k) &#123;</span><br><span class="line"><span class="keyword">return</span> __kth(k, tree[p].ch[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tree[tree[p].ch[<span class="number">0</span>]].sz + tree[p].cnt &lt; k) &#123;</span><br><span class="line"><span class="keyword">return</span> __kth(k - tree[tree[p].ch[<span class="number">0</span>]].sz - tree[p].cnt, tree[p].ch[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tree[p].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> __kth(k, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> r = <span class="built_in">countl</span>(x, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> __kth(r, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">suc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> r = tree[<span class="number">1</span>].sz - <span class="built_in">countg</span>(x, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> __kth(r, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="built_in">insert</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> last = <span class="number">0</span>, op, x;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">cin &gt;&gt; op &gt;&gt; x;</span><br><span class="line">x ^= last;</span><br><span class="line"><span class="keyword">if</span> (op == <span class="number">1</span>) <span class="built_in">insert</span>(x);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) <span class="built_in">remove</span>(x);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) &#123;</span><br><span class="line">last = <span class="built_in">rk</span>(x);</span><br><span class="line">ans ^= last;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">4</span>) &#123;</span><br><span class="line">last = <span class="built_in">kth</span>(x);</span><br><span class="line">ans ^= last;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">5</span>) &#123;</span><br><span class="line">last = <span class="built_in">pre</span>(x);</span><br><span class="line">ans ^= last;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">6</span>) &#123;</span><br><span class="line">last = <span class="built_in">suc</span>(x);</span><br><span class="line">ans ^= last;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;第一要务是收心，不要去在意杂事，不担心以后，最后几个月专心做竞赛，不留下遗憾。&lt;/p&gt;
&lt;h1 id=&quot;8-25-8-26-Codeforces-Round-767-Div-1&quot;&gt;&lt;a href=&quot;#8-25-8-26-Codeforces-Round-767-Div-1&quot;</summary>
      
    
    
    
    <category term="XCPC" scheme="https://eykenis.github.io/categories/XCPC/"/>
    
    
    <category term="XCPC" scheme="https://eykenis.github.io/tags/XCPC/"/>
    
  </entry>
  
  <entry>
    <title>BRDF 和 Blinn-Phong</title>
    <link href="https://eykenis.github.io/2022/06/21/BasicShadersImplements/"/>
    <id>https://eykenis.github.io/2022/06/21/BasicShadersImplements/</id>
    <published>2022-06-21T13:43:46.000Z</published>
    <updated>2022-07-09T14:51:29.752Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/20220310232734.png" alt=""></p><h1 id="了解-BRDF-—-标准光照模型"><a href="#了解-BRDF-—-标准光照模型" class="headerlink" title="了解 BRDF — 标准光照模型"></a>了解 BRDF — 标准光照模型</h1><p>BRDF 是真实化渲染一个重要的模型。以下实现的各种渲染方法都将符合 BRDF 的规则。</p><p>首先可以参考这篇论文：<a href="www.cs.princeton.edu/courses/archive/fall06/cos526/tmp/wynn.pdf">A Basic Introduction to BRDF-Based Lighting</a></p><p>(((</p><p>在了解渲染方法之前，你应该首先知晓渲染管线的基本流程。</p><p>标准光照模型 - BRDF (Bi-directional Reflectance  Distribution Function，也称双向反射模型) 是一种广泛用于图形渲染的光照模型。它的基本方法是将进入摄像机的光分为四部分：</p><p><strong>自发光</strong>、<strong>高光反射</strong>、<strong>漫反射</strong> 和 <strong>环境光</strong>.</p><ul><li><strong>自发光</strong> (emissive) 即物体本身向摄像机辐射的光（而非折射/反射）。如果你没有使用<strong>全局光照</strong>技术，自发光并不会让物体看起来在发光，而只是亮度提高了。使用全局光照后，自发光的物体可以影响附近物体的光照。</li><li><strong>高光反射</strong> (specular) 即模型向摄像机完全镜面反射的光强。</li><li><strong>漫反射</strong> (diffuse) 即模型接收到光照后，向所有方向反射的光强。该值与视角无关。</li><li><strong>环境光</strong> (ambient) 除以上三点以外的所有其他光照。这些一般都是间接光照。例如前面提到的全局光照。环境光一般是必须的，如果没有环境光，没有受到光源直线照射的地方将完全黑暗，这是不符合实际的。（在素描中也学过，暗面和阴影的交界处是有些许反光的）</li></ul><p>最后一个片元呈现的颜色就是这四种光的线性和。</p><p>除开双向反射模型以外，还有一种双向透射模型（BTDF），一般用于表现透明材质。二者统称为双向散射模型（BSDF）。</p><h2 id="漫反射光照的兰伯特定律"><a href="#漫反射光照的兰伯特定律" class="headerlink" title="漫反射光照的兰伯特定律"></a>漫反射光照的兰伯特定律</h2><p>兰伯特定律的表述很简单：</p><script type="math/tex; mode=display">I=k_d·{\vec n} ·\vec l</script><p>如上公式， $I$ 为光强，$\vec n, \vec l$ 分别为归一化后的表面法向量和光照方向，如下图所示（图来自《Unity Shader 入门精要》）：</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/20220315093831.png" alt="image-20220310215956093"></p><p>其中，$k_d$ 是漫反射系数，由<strong>材质颜色乘以光线强度</strong>得到。</p><p>那么公式的意义实际上就是说漫反射的光强与法线和光源方向夹角的余弦值成正比（因为 $\vec n · \vec l=cos(\vec n, \vec l)$）。这和我们的感性认识——表面的角度偏离光源越远光照越少，是一致的。</p><p>这一定律在各种 Shading methods 中广泛使用。</p><p>下面来看看基于 BRDF 的经验模型是如何实现的。</p><h2 id="Phong-Shading-amp-Gouraud-Shading"><a href="#Phong-Shading-amp-Gouraud-Shading" class="headerlink" title="Phong Shading &amp; Gouraud Shading"></a>Phong Shading &amp; Gouraud Shading</h2><p> 冯（Phong）着色与高洛德（Gouraud）着色都是最经典的经验 Shading. 而且着色算法也是一样的。唯一的不同就是：Phong Shading 是在片元着色器阶段对每一个片元操作的，而 Gouraud Shading 是对顶点操作的。下面根据 BRDF 的四个光照部分来引入这两种 Shading 的公式。</p><h3 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h3><p>漫反射部分直接使用 Lambert law 即可：</p><script type="math/tex; mode=display">c_{diffuse}=(c_{light}·m_{diffuse})\max(0,\vec{n}·\vec{l})</script><p>其中，将漫反射颜色 $m_{diffuse}$ 与光照强度 $c_{light}$ 相乘，并保证漫反射取正值，这样可以防止物体在背光处被光源直接照亮。</p><h3 id="高光反射"><a href="#高光反射" class="headerlink" title="高光反射"></a>高光反射</h3><p>还是本文第一张图，Phong 模型通过如下公式计算高光反射：</p><script type="math/tex; mode=display">c_{specular} = (c_{light}·m_{specular})\max(0,\vec{v}·\vec r)^{m_{gloss}}</script><p>其中，$\vec v$ 为视线向量，$\vec r$ 是反射方向向量。</p><p>不过，对于高光的计算，还有另一种经验计算方法—— Blinn 模型，它使用一个新的矢量 $\vec h=normalize(\vec {v + l})$ ，公式为</p><script type="math/tex; mode=display">c_{specular} = (c_{light}·m_{specular})\max(0,\vec{n}·\vec h)^{m_{gloss}}</script><p>其实 Phong 模型和 Blinn 模型高光计算方法都是经验模型，在不同的情况下有不同的表现，不一定 Phong 更加符合实验结果。而 Blinn 的区别主要在于，当视角不动时，其计算的 $\vec h$ 几乎是一个常量，由此节约了性能。而在高速移动的视角下 Phong 模型也许更快。</p><p>总之，使用 Blinn 高光算法的模型一般也称为 Blinn-Phong Shading.</p><h3 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h3><p>对于简单的 Blinn-Phong 模型，环境光给一个全局常量即可（敷衍就行了）。例如在 Unity Shader 中，你可以把 <code>UNITY_LIGHTMODEL_AMBIENT</code> 拿来当环境光。</p><h3 id="自发光"><a href="#自发光" class="headerlink" title="自发光"></a>自发光</h3><p>和环境光一样，自发光也只使用一个固定常数。</p><p>总之，Blinn-Phong 模型只是一个经验模型，很多地方都做得很简单。和真实的物理光照是不同的，但表现出来的效果可以八九不离十。这也就是某一般路过（误）邓恩（<em>3D Math Primer For Graphics And Game Development</em> 的 writer）提出的图形学第一定律所说：</p><blockquote><p>如果它看起来是对的，那么它就是对的。</p></blockquote><p>如果你将以上过程应用到顶点着色器而不是片元着色器，那么你会得到一个更粗糙的着色效果，也就是 Gouraud Shading.</p><p>下面是不含高光部分的代码实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// Gauraud</span><br><span class="line">v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex); // MVP transformation</span><br><span class="line">                o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line">            fixed4 frag(v2f v) : SV_TARGET0 &#123;</span><br><span class="line"></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                </span><br><span class="line">                fixed3 worldNormal = normalize(v.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line"></span><br><span class="line">                fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - v.worldPos.xyz);</span><br><span class="line">                fixed3 halfDir = normalize(worldLightDir + viewDir);</span><br><span class="line"></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Color.rgb * saturate(dot(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">                return fixed4(ambient + diffuse, 1.0);</span><br><span class="line">            &#125;</span><br><span class="line">// Phong</span><br><span class="line">v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                fixed3 worldNormal = normalize(mul(v.normal, (float3x3)unity_WorldToObject));</span><br><span class="line">                fixed3 worldLight = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLight));</span><br><span class="line">                o.color = ambient + diffuse;</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line">            fixed4 frag(v2f v) : SV_TARGET0 &#123;</span><br><span class="line">                return fixed4(v.color, 1.0);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>高光如何实现呢？</p><p>且回看上方高光公式。简单地加一个高光向量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(v.worldNormal.xyz, halfDir)), _Gloss);</span><br></pre></td></tr></table></figure><p>这里采用的是 <code>Blinn</code> 方法， <code>_Specular</code> 是高光的颜色向量。另外，halfdir 的计算：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fixed3 halfDir = normalize(worldLightDir + viewDir);</span><br></pre></td></tr></table></figure><p>最后和 <code>ambient + diffuse</code> 直接相加。</p><h3 id="Half-Lambert"><a href="#Half-Lambert" class="headerlink" title="Half-Lambert"></a>Half-Lambert</h3><p>普通的 Lambert 方法处理的背光面会出现和真实情况相差甚远的情况——整个背光面都是黑的，没有亮度差别。而在实际观察中，即使是背光面也是存在量不同的反光的，只使用一个统一的环境反射光来表现显然不能解决问题。</p><p>问题的出现是因为使用的公式是 <code>saturate(dot(worldNormal, worldLight)</code>，对点积小于 0 的部分直接舍去用 0 代替，背光面出现大量亮度都为 0 的片元。</p><p>所以对 Lambert 进行一个重新取值，公式修改为</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20220624102948113.png" alt="image-20220624102948113"></p><p>对比如下：</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20220623165408197.png" alt="image-20220623165408197"></p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/image-20220623165359932.png" alt="image-20220623165359932"></p><p>不管怎样，两种渲染方式都缺少明暗交界线，是经验模型下单光源光照的缺点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://ekkepic.oss-cn-beijing.aliyuncs.com/img/20220310232734.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;了解-BRDF-—-标准光照模型&quot;&gt;&lt;a href=&quot;#了解-BRDF-—-标</summary>
      
    
    
    
    <category term="问道" scheme="https://eykenis.github.io/categories/%E9%97%AE%E9%81%93/"/>
    
    
  </entry>
  
  <entry>
    <title>读 Operating Systems - Three Easy Pieces</title>
    <link href="https://eykenis.github.io/2022/04/20/OSTEP-Reading/"/>
    <id>https://eykenis.github.io/2022/04/20/OSTEP-Reading/</id>
    <published>2022-04-20T15:56:53.000Z</published>
    <updated>2022-04-24T03:19:39.536Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前半个学期基本上没怎么碰过三大系统（OS，CS，DB），到了期中复习才意识到应该好好学一学了。所以我打算在接下来的半个学期将 OSTEP 和 CSAPP 好好读一读，特别是 OSTEP<del>（毕竟 CSAPP 很多内容很难啃，不是那么好读，而 OSTEP 全是废话）</del>。</p><p>我将会在<a href="https://github.com/Eykenis/OSTEP-Reading">这里</a>详细地记录自己的读书笔记。一起加油！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;前半个学期基本上没怎么碰过三大系统（OS，CS，DB），到了期中复习才意识到应该好好学一学了。所以我打算在接下来的半个学期将 OSTEP 和</summary>
      
    
    
    
    <category term="问道" scheme="https://eykenis.github.io/categories/%E9%97%AE%E9%81%93/"/>
    
    
    <category term="OS" scheme="https://eykenis.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>在 ECS 服务器（Ubuntu）上使用 Mirai 机器人</title>
    <link href="https://eykenis.github.io/2022/02/24/Use-Mirai-in-ur-ECS-server/"/>
    <id>https://eykenis.github.io/2022/02/24/Use-Mirai-in-ur-ECS-server/</id>
    <published>2022-02-24T11:01:20.000Z</published>
    <updated>2022-04-22T06:37:43.753Z</updated>
    
    <content type="html"><![CDATA[<p>最近玩了一会 Mirai 机器人框架，在本地的话不说多少占了电脑资源，一直开着也不太好。但耐不住各群群友都想深夜看 bot 发病，正好想起来上学期学校发的 200 元华为云代金券没用，故斥巨资 1.83 RMB 买了一台配置最低的 ECS 服务器。正好，从零开始记录一下安装 Mirai 以及使用的过程。我这里使用的镜像是 Ubuntu 20.04.</p><h2 id="1-登录并安装-Mirai-Console-Loader"><a href="#1-登录并安装-Mirai-Console-Loader" class="headerlink" title="1. 登录并安装 Mirai Console Loader"></a>1. 登录并安装 Mirai Console Loader</h2><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/20220224190641.png" alt=""></p><p>利用华为云自带的 CloudShell 登录到实例。（不过比较推荐 PuTTY）</p><p>为了尽可能地让我们的工作更简单，使用 <a href="https://github.com/iTXTech/">iTXTech</a> 的 iTXTech MCL。其在 github 上自带 <a href="https://github.com/iTXTech/mcl-installer">Installer</a>.</p><p>这里我选择 <a href="https://github.com/iTXTech/mcl-installer/releases/download/v1.0.3/mcl-installer-1.0.3-linux-amd64">mcl-installer-1.0.3-linux-amd64</a>，执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/iTXTech/mcl-installer/releases/download/v1.0.3/mcl-installer-1.0.3-linux-amd64</span><br></pre></td></tr></table></figure><p><code>wget</code> 是 linux 系统常用的从 url 下载文件的命令。</p><p>如果下载完成后你想直接启动这个可执行文件是不行的，会提示没有权限。</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/20220224195931.png" alt=""></p><p>这个时候，执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x mcl-installer-1.0.3-linux-amd64</span><br></pre></td></tr></table></figure><p><code>chmod</code> 是一个修改文件权限的命令。其中 <code>u</code> 表示目标是用户，<code>x</code> 表示执行权限，<code>+</code> 表示给与。</p><p>缺省的安装过程是可接受的（至少对我这个啥也没有的新机是这样），一路回车等待安装完成，Y 和 N 都不用按了（</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/20220224200506.png" alt=""></p><p>根据提示，这个时候只需要 <code>./mcl</code> 就可以启动 Mirai Console 了.</p><p>启动后，继续等待安装。</p><p>完成之后重启，再次 <code>./mcl</code>，成功启动。</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/20220224200925.png" alt=""></p><h2 id="2-文件迁移到远程机上"><a href="#2-文件迁移到远程机上" class="headerlink" title="2. 文件迁移到远程机上"></a>2. 文件迁移到远程机上</h2><p>现在我们把原来在 本地 Windows 上的插件迁移过去。</p><p>为了确保记录都成功迁移，记得将 plugins、data、conf 三个文件夹都粘贴过来。</p><p>为了能有粘贴功能，我们在本地 Windows 机安装 <a href="[Download PuTTY: latest release (0.76">pscp</a> (greenend.org.uk)](<a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html))，下载完成后将其拷贝到">https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html))，下载完成后将其拷贝到</a> C:\Windows\System32 下。</p><p>打开本地的 PowerShell，输入 <code>pscp</code>，确认 pscp 已经正确安装。</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/20220224203057.png" alt=""></p><p>好，现在开始拷贝。输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pscp -r dir name@IP:target</span><br></pre></td></tr></table></figure><p>其中，dir 改为要拷贝的目录，name 为远程主机名，IP 为 IP地址，target 为目标目录。</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/20220224203810.png" alt=""></p><p>成功粘贴过来之后，再将这些目录下的东西都拷贝到 mcl 相应的目录中去。（或者你直接 pscp 到目标目录也行）</p><p>等待拷贝全部完成后，再次 <code>./mcl</code> ，发现所有插件都装上了。现在尝试登录机器人。</p><p><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/20220224204944.png" alt=""></p><p>发现需要验证滑动验证码。没有办法，查看 <a href="https://github.com/project-mirai/mirai-login-solver-selenium">project-mirai/mirai-login-solver-selenium: SliderCaptcha solver (github.com)</a></p><p>读我文档，按照文档所说一步一步来吧 QWQ。总之，登陆成功后， Mirai 又可以正常使用了。</p><hr><p>呃，这下水文章了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近玩了一会 Mirai 机器人框架，在本地的话不说多少占了电脑资源，一直开着也不太好。但耐不住各群群友都想深夜看 bot 发病，正好想起来上学期学校发的 200 元华为云代金券没用，故斥巨资 1.83 RMB 买了一台配置最低的 ECS 服务器。正好，从零开始记录一下安装</summary>
      
    
    
    
    <category term="问道" scheme="https://eykenis.github.io/categories/%E9%97%AE%E9%81%93/"/>
    
    
    <category term="Mirai" scheme="https://eykenis.github.io/tags/Mirai/"/>
    
    <category term="Linux" scheme="https://eykenis.github.io/tags/Linux/"/>
    
    <category term="聊天bot" scheme="https://eykenis.github.io/tags/%E8%81%8A%E5%A4%A9bot/"/>
    
  </entry>
  
  <entry>
    <title>Treap学习笔记及模板</title>
    <link href="https://eykenis.github.io/2021/12/14/Treap%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%8F%8A%E6%A8%A1%E6%9D%BF/"/>
    <id>https://eykenis.github.io/2021/12/14/Treap%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%8F%8A%E6%A8%A1%E6%9D%BF/</id>
    <published>2021-12-14T02:33:32.000Z</published>
    <updated>2023-03-20T07:04:30.313Z</updated>
    
    <content type="html"><![CDATA[<p>Treap是平衡搜索树的一种。所谓 “Treap”，即 “Tree” + “Heap”, 顾名思义，是使用堆方法对搜索树进行平衡的一种数据结构。</p><p>约定该篇文章讨论的二叉搜索树都遵守 “比当前节点值大的节点在右子树，小于等于当前节点值的节点在其左子树” 这一规定。</p><h2 id="Treap维护平衡的方式"><a href="#Treap维护平衡的方式" class="headerlink" title="Treap维护平衡的方式"></a>Treap维护平衡的方式</h2><p>Treap的目的主要是利用堆的性质来平衡原搜索树。因为堆是一棵完全二叉树，深度最优嘛。</p><p>对于一棵普通的二叉搜索树，我们对其每个节点再随机赋上一个优先级权值 $p$. 即对任意节点，多了一个变量 $p=random()$.</p><p>例如，如果我们以小根堆的规则来约束这个平衡树，那么插入和删除两个主要操作就会变成这样：</p><p><strong>插入</strong>：先按照普通平衡树的方式将元素插入到合适位置。然后我们需要向上回溯，在回溯的过程中检查这些节点关于 $p$ 是否符合小根堆的性质。如果当前节点的 $p$ 大于左右子节点 $p$ 的最小值，那么就不符合小根堆的性质。这个时候，如果左子节点的 $p$ 更小，我们就需要左旋，反之需要右旋，以此保证平衡。</p><p>至于旋转的具体操作，即：</p><blockquote><p>以右旋为例：</p><ol><li>将当前节点下放至其左子节点的位置</li><li>令<strong>右子节点的左子节点</strong> 称为当前节点的新的右子节点</li><li>右子节点的左子节点变为当前节点，取代当前节点的位置</li></ol></blockquote><p>删除操作当然是同理了，回溯的时候观察 $p$ 来维护平衡。由于 $p$ 值是随机的， Treap也不是严格的堆结构，所以它是一种期望平衡的<strong>弱平衡</strong>的平衡树，搜索、插入和删除的期望时间复杂度为 $O(\log n)$.</p><p>Treap的优势在于其实现起来非常简单，包含的也就上面这些东西了。</p><h2 id="模板部分"><a href="#模板部分" class="headerlink" title="模板部分"></a>模板部分</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt; <span class="comment">// cnt 表示当前treap内节点总数，用于动态开点</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = XXXXX;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="comment">// 分别表示左右子节点、所在子树的大小、当前节点值以及p值</span></span><br><span class="line">    <span class="keyword">int</span> l, r, size, val, p;</span><br><span class="line">&#125;a[maxn];</span><br></pre></td></tr></table></figure><h3 id="回溯统计"><a href="#回溯统计" class="headerlink" title="回溯统计"></a>回溯统计</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    a[k].size = a[a[k].l].size + a[a[k].r].size + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 右旋</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rrotate</span><span class="params">(<span class="keyword">int</span> &amp;k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = a[k].l;</span><br><span class="line">    a[k].l = a[tmp].r;</span><br><span class="line">    a[tmp].r = k;</span><br><span class="line">    a[tmp].size = a[k].size;</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">    k = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左旋</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lrotate</span><span class="params">(<span class="keyword">int</span> &amp;k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = a[k].r;</span><br><span class="line">    a[k].r = a[tmp].l;</span><br><span class="line">    a[tmp].l = k;</span><br><span class="line">    a[tmp].size = a[k].size;</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">    k = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;k, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        k = ++cnt;</span><br><span class="line">        a[k].val = val;</span><br><span class="line">        a[k].p = <span class="built_in">rand</span>();</span><br><span class="line">        a[k].size = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a[k].size++;</span><br><span class="line">    <span class="keyword">if</span> (val &gt;= a[k].val) &#123;</span><br><span class="line">        <span class="built_in">ins</span>(a[k].r, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">ins</span>(a[k].l, val);</span><br><span class="line">    <span class="keyword">if</span> (a[k].l &amp;&amp; a[k].p &gt; a[a[k].l].p) &#123;</span><br><span class="line">        <span class="built_in">rrotate</span>(k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[k].r &amp;&amp; a[k].p &gt; a[a[k].r].p) &#123;</span><br><span class="line">        <span class="built_in">lrotate</span>(k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> &amp;k, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    a[k].size--;</span><br><span class="line">    <span class="keyword">if</span> (a[k].val == val) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!a[k].l &amp;&amp; !a[k].r) &#123;</span><br><span class="line">            k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!a[k].l || !a[k].r) &#123;</span><br><span class="line">            k = a[k].l + a[k].r;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[a[k].l].p &lt; a[a[k].r].p) &#123;</span><br><span class="line">            <span class="built_in">rrotate</span>(k);</span><br><span class="line">            <span class="built_in">del</span>(a[k].r, val); <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">lrotate</span>(k);</span><br><span class="line">            <span class="built_in">del</span>(a[k].l, val); <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[k].val &gt;= val) &#123;</span><br><span class="line">        <span class="built_in">del</span>(a[k].l, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">del</span>(a[k].r, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>例题分割线~</p><p>例题：</p><h3 id="P3369-【模板】普通平衡树"><a href="#P3369-【模板】普通平衡树" class="headerlink" title="P3369 【模板】普通平衡树"></a><a href="https://www.luogu.com.cn/problem/P3369">P3369 【模板】普通平衡树</a></h3><p>其中还要维护查询排名，查询前驱后继等搜索操作。</p><p>当普通平衡树维护就可以啦，比较简单。</p><p>完整代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> root;</span><br><span class="line"><span class="comment">// 注意按p是小根堆</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, size, val, p;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    a[k].size = <span class="number">1</span> + a[a[k].l].size + a[a[k].r].size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rrotate</span><span class="params">(<span class="keyword">int</span> &amp;k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = a[k].l;</span><br><span class="line">    a[k].l = a[tmp].r;</span><br><span class="line">    a[tmp].r = k;</span><br><span class="line">    a[tmp].size = a[k].size;</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">    k = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lrotate</span><span class="params">(<span class="keyword">int</span> &amp;k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = a[k].r;</span><br><span class="line">    a[k].r = a[tmp].l;</span><br><span class="line">    a[tmp].l = k;</span><br><span class="line">    a[tmp].size = a[k].size;</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">    k = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;k, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        k = ++cnt;</span><br><span class="line">        a[k].val = val;</span><br><span class="line">        a[k].p = <span class="built_in">rand</span>();</span><br><span class="line">        a[k].size = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a[k].size++;</span><br><span class="line">    <span class="keyword">if</span> (val &gt;= a[k].val) &#123;</span><br><span class="line">        <span class="built_in">ins</span>(a[k].r, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">ins</span>(a[k].l, val);</span><br><span class="line">    <span class="keyword">if</span> (a[k].l &amp;&amp; a[k].p &gt; a[a[k].l].p) &#123;</span><br><span class="line">        <span class="built_in">rrotate</span>(k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[k].r &amp;&amp; a[k].p &gt; a[a[k].r].p) &#123;</span><br><span class="line">        <span class="built_in">lrotate</span>(k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> &amp;k, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    a[k].size--;</span><br><span class="line">    <span class="keyword">if</span> (a[k].val == val) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!a[k].l &amp;&amp; !a[k].r) &#123;</span><br><span class="line">            k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!a[k].l || !a[k].r) &#123;</span><br><span class="line">            k = a[k].l + a[k].r;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[a[k].l].p &lt; a[a[k].r].p) &#123;</span><br><span class="line">            <span class="built_in">rrotate</span>(k);</span><br><span class="line">            <span class="built_in">del</span>(a[k].r, val); <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">lrotate</span>(k);</span><br><span class="line">            <span class="built_in">del</span>(a[k].l, val); <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[k].val &gt;= val) &#123;</span><br><span class="line">        <span class="built_in">del</span>(a[k].l, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">del</span>(a[k].r, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rk</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (val &gt; a[k].val) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[a[k].l].size + <span class="built_in">rk</span>(a[k].r, val) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rk</span>(a[k].l, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> rnk)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rnk == a[a[k].l].size + <span class="number">1</span>) <span class="keyword">return</span> a[k].val;</span><br><span class="line">    <span class="keyword">if</span> (rnk &gt; a[a[k].l].size + <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">find</span>(a[k].r, rnk - a[a[k].l].size - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(a[k].l, rnk);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query_pre</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[k].val &gt;= val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query_pre</span>(a[k].l, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="built_in">query_pre</span>(a[k].r, val);</span><br><span class="line">    <span class="keyword">if</span> (!tmp) <span class="keyword">return</span> a[k].val;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query_suf</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[k].val &lt;= val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query_suf</span>(a[k].r, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="built_in">query_suf</span>(a[k].l, val);</span><br><span class="line">    <span class="keyword">if</span> (!tmp) <span class="keyword">return</span> a[k].val;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> opt, x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; opt &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">ins</span>(root, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">del</span>(root, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">3</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">rk</span>(root, x) + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">4</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">find</span>(root, x) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">5</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">query_pre</span>(root, x) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">query_suf</span>(root, x) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">最简单的平衡树之一</summary>
    
    
    
    <category term="XCPC" scheme="https://eykenis.github.io/categories/XCPC/"/>
    
    
    <category term="平衡树" scheme="https://eykenis.github.io/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
    <category term="Treap" scheme="https://eykenis.github.io/tags/Treap/"/>
    
  </entry>
  
  <entry>
    <title>快速傅里叶变换(FFT)及NTT入门笔记</title>
    <link href="https://eykenis.github.io/2021/11/18/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2-FFT-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <id>https://eykenis.github.io/2021/11/18/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2-FFT-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</id>
    <published>2021-11-18T13:41:50.000Z</published>
    <updated>2023-06-28T01:11:59.139Z</updated>
    
    <content type="html"><![CDATA[<p>本博客学习于洛谷P3803各路大佬题解，所以你肯定会找到很多相似的地方QWQ</p><h2 id="什么是FFT"><a href="#什么是FFT" class="headerlink" title="什么是FFT"></a>什么是FFT</h2><p><strong>傅里叶变换</strong></p><p>傅里叶说明了：一切函数/波形都可以用有限或无限个弦函数/波形叠加形成。</p><p>例如，现在有一个由三个不同正弦波组成的近似矩形波，将这些波形关于 $x$ 轴平行地放在一起，就可以得到下图：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/97b88cfe9192ba702c13e817170e7a08.png" alt="img"></p><p>其中红色的是合成出来的近似矩形波。</p><p>（当然，图肯定是不太标准的，意思一下就行）</p><p>从 $xOz$ 平面看，我们可以获得各个波的时域信号，也就是 $t-f(t)$ 图像。而从 $zOy$ 平面看，则可以获得各个波的频域信号。</p><p>先不看频域信号中的红色部分，注意其他三个波其实是有排序规则的：按照频率大小排序。也就是说，频率越快， $y$ 越大。且每个频率下的 $z$ 将反映该波的振幅。两种不同的信号包含了不同的信息。</p><p>而傅里叶变换，就是对一个时域信号作变换，生成频域信号。</p><p><strong>离散傅里叶变换（DFT）</strong></p><p>顾名思义，离散傅里叶变换就是在确定时域信号和频域信号都是离散的时候作的傅里叶变换。</p><p>例如，现在有一个多项式函数 $f(x)=\sum_{i=0}^{n}a_ix^i$，那么这个函数其实就是“时域信号”，我们也可以将其表示成点集$\{P_0,P_1,…,P_n\}$，其中 $P_i$ 是函数图像上的某一个点。容易知道 $n$ 个点是可以确定一个 $n-1$ 次多项式的。那么这个点集其实就是“频域信号”。从函数式到点集的变化，就是一种离散傅里叶变换。</p><p>另外，我们称IDFT为DFT的逆运算，即从点集得到函数式的运算。</p><h2 id="为什么需要FFT"><a href="#为什么需要FFT" class="headerlink" title="为什么需要FFT"></a>为什么需要FFT</h2><p>离散型傅里叶变换解决的问题一般是多项式乘法问题。</p><p>最经典的FFT问题即多项式卷积问题：</p><p><a href="https://www.luogu.com.cn/problem/P3803">P3803 【模板】多项式乘法（FFT） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>给一个 $n$ 次多项式 $F(x)$ 和一个 $m$ 次多项式 $G(x)$，求 $F(x)$ 和 $G(x)$ 的卷积。</p><p>如果直接暴力计算，第一种就是直接展开函数式算，第二种就是执行一次DFT，将函数式转换为点集，通过对 $x$ 相同的点的 $y$ 值相乘，得到目标函数的点集，再通过 DFT 的逆运算 IDFT 转化为答案。</p><p>显然，不管采取哪种方法，一共都有 $m · n$ 项，复杂度为 $O((max\{n, m\})^2)$. 在 $nm\geq 1e9$ 的时候是无法接受的。虽然朴素方法下第二种方法的常数肯定比第一种还要大，但其实我们可以在DFT变换的基础上使用FFT来加速多项式乘法。实际上，FFT的加速原因在于其采用了分治的思想。</p><h2 id="多项式乘法问题"><a href="#多项式乘法问题" class="headerlink" title="多项式乘法问题"></a>多项式乘法问题</h2><h3 id="前置知识-复数根"><a href="#前置知识-复数根" class="headerlink" title="前置知识-复数根"></a>前置知识-复数根</h3><p>考虑欧拉公式</p><script type="math/tex; mode=display">e^{\theta i}= \cos\theta + i\sin\theta</script><p>，容易知道 $e^{2\pi i}=1$.</p><p>不妨令 $w_n=e^{2\pi i\over n}=\sin{2\pi\over n}+i\cos{2\pi\over n}$, 则 $w_n^n=1$.</p><p>则称 $w_n$ 为 $n$ 的一个复数z单位根. 容易知道 $n$ 的复数根最多有 $n$ 个，为 $\{w_i|i\in [0,n-1]\}$. 这是因为复数根具有性质 $w_n^{n+k}=w_n^k$.</p><p>另外，还有一个通过消去定理得到的引理：$w_n^k=w_{n\over2}^{k\over2}$.</p><h3 id="使用FFT解决多项式乘法问题"><a href="#使用FFT解决多项式乘法问题" class="headerlink" title="使用FFT解决多项式乘法问题"></a>使用FFT解决多项式乘法问题</h3><p>例题：</p><p><a href="https://www.luogu.com.cn/problem/P3803">P3803 【模板】多项式乘法（FFT）</a></p><p><strong>DFT</strong></p><p>现在要将$F(x)$的表达式转化为点值表示法，那么我们需要取$n$个点。前面已经讨论过，朴素的取法复杂度是 $O(n^2)$ 的，现在我们需要构造一个可以分治的取法：</p><p>设$ F(x)$ 的项数 $n$ 为偶数，并令</p><p>$A(x)=a_0+a_2x+a_4x^2+…+a_nx^{n\over 2}$,</p><p>$B(x)=a_1+a_3x+a_5x^2+…+a_{n-1}x^{\frac{n}{2}-1}$.</p><p>则 $F(x)=A(x^2)+xB(x^2)$.</p><p>代入 $n$ 个单位复数根 $w_n^k, k\in[0, n - 1]$，有</p><p>$F(w_n^k)=A(w_{n}^{2k})+w_n^kB(w_n^{2k})$</p><p>而 $A(w_n^{2k})=a_0+a_2w_n^{2k}+…+a_nw_n^{2k\over n}$</p><p>$=a_0+a_2w_{n\over2}^k+…+a_nw_{n\over2}^{k\over n}$.</p><p>且对 $B(w_n^{2k})$，我们也有相似的结论。</p><p>故</p><p>$F(w_n^k)=A(w_{n\over2}^k)+w_n^kB(w_{n\over2}^{k})\ (k&lt;{n\over2})$.</p><p>考虑 $k\geq {n\over2}$ 的情况，令 $k+{n\over 2}$ 取代原来位置上的 $k$,</p>$F(w_n^{{n\over 2}+k})=A(w_n^{n+2k})+w_n^{{n\over 2}+k}B(w_n^{2k})$,$=A(w_n^{2k})-w_n^{k}B(w_n^{2k})$,$=A(w_{n\over2}^k)-w_n^kB(w_{n\over2}^k)$.那么在求 $F(w_n^k)$ 时，我们可以先求 $A(w_{n\over2}^{k})$ 以及 $B(w_{n\over2}^{k})$，然后再合并出 $F(w_n^k)$. 到这里，分治递归的可行性就十分显然了。由主定理可知复杂度为 $T(n)=T(\frac{n}{2})+O(n)=O(n\log n)$.**IDFT**IDFT 即 DFT 的逆变换。我们的目的是求最终表达式的各个系数，而通过 DFT 得到最终的点值表达式后，我们还需要将其逆向变回系数表达式。其实，这里只需要取 $w'=\overline {w_n^k}$. 即单位根的共轭复数，然后再执行一遍相似的分治，并且最后得到的多项式系数都除以一个 $n $ 就可以了。（不再展开证明 QWQ，了解就好，因为本蒟蒻也不会）CPP:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// F[]即F(x)，注意n为A(x),B(x)的长度，op为1/-1表示进行的是FFT/IDFT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(complex&lt;<span class="keyword">double</span>&gt; F[], <span class="keyword">int</span> n, <span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n) <span class="keyword">return</span>;</span><br><span class="line">    complex&lt;<span class="keyword">double</span>&gt; a[n], b[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        a[i] = F[i &lt;&lt; <span class="number">1</span>], b[i] = F[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FFT</span>(a, n &gt;&gt; <span class="number">1</span>, op), <span class="built_in">FFT</span>(b, n &gt;&gt; <span class="number">1</span>, op);</span><br><span class="line">    <span class="function">complex&lt;<span class="keyword">double</span>&gt; <span class="title">wn</span><span class="params">(cos(PI / n), sin(PI / n) * op)</span>, <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        F[i] = a[i] + w * b[i];</span><br><span class="line">        F[i + n] = a[i] - w * b[i];</span><br><span class="line">        w *= wn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>此为FFT的递归写法，由于单位根的原因需要使用 `double` 数据类型，且需要一个复数结构体，每层分治还要额外开数组，其常数比较大。另外还有一种FFT的迭代写法，常数更小。（需要的可以去别处找，或者我说不定会更？QAQ）****回到该问题，由于需要分治的任何时候都要保证 $n$ 为偶数，故我们需要把 $n,m$ 补成相同的一个 $2$ 的幂次方。项数补全不影响结果，只要让多出来的项系数都为0就行了。故整个流程即：1. 对 $F(x),G(x)$ 分别求 DFT2. 直接将每个点值相乘3. 通过IDFT将点值还原成系数表达式，得到答案对于例题[P3803](https://www.luogu.com.cn/problem/P3803)，AC代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// op = 1 ? DFT : IDFT</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e6</span> + <span class="number">10</span>;</span><br><span class="line">complex &lt;<span class="keyword">double</span>&gt; F[maxn], G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(complex&lt;<span class="keyword">double</span>&gt; f[], <span class="keyword">int</span> n, <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n) <span class="keyword">return</span>;</span><br><span class="line">    complex &lt;<span class="keyword">double</span>&gt; a[n], b[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">        a[k] = f[k &lt;&lt; <span class="number">1</span>], b[k] = f[k &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fft</span>(a, n &gt;&gt; <span class="number">1</span>, op), <span class="built_in">fft</span>(b, n &gt;&gt; <span class="number">1</span>, op);</span><br><span class="line">    <span class="function">complex&lt;<span class="keyword">double</span>&gt; <span class="title">wn</span><span class="params">(cos(PI / n), sin(PI / n) * op)</span>, <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k, w *= wn) &#123;</span><br><span class="line">        f[k] = a[k] + w * b[k], f[k + n] = a[k] - w * b[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;F[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;G[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    m += n, n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n &lt;= m) n &lt;&lt;= <span class="number">1</span>; <span class="comment">// 补足系数，保证是2的幂次</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// DFT</span></span><br><span class="line">    <span class="built_in">fft</span>(F, n &gt;&gt; <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">fft</span>(G, n &gt;&gt; <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) F[i] *= G[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IDFT</span></span><br><span class="line">    <span class="built_in">fft</span>(F, n &gt;&gt; <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.0f &quot;</span>, <span class="built_in">fabs</span>(F[i].<span class="built_in">real</span>()) / n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>基本上和洛谷上 FlashHu 的题解代码一样...因为我的FFT基本上是从这里理解的## NTT-快速数论变换很多时候，要求的多项式系数并不会有多大，`double` 显得有些浪费空间了，而且很容易产生精度问题。故可以使用另一种 “原根” 替代复数来解决多项式乘法问题，这样就可以避免使用 `double` 以及 `complex<T>`. 如果有系数较大的多项式需要计算且考察 NTT 时，一般会要求对结果取模。### 前置知识-原根在 NTT 算法中，原根是 FFT 中复数的替代品。~~（？又说一遍）~~要理解原根，首先我们需要群论中的若干定义。**循环群**如果一个群 $A$ 的所有元素 $x$ 都是 $a$ 的幂次，即$\forall x\in A, x=a^i(i\in \Z)$，则称 $A$ 是一个循环群，$a$ 是它的生成元。**阶**假设 $e$ 是某个循环群的单位元，则若 $a^p=1$，则 $p$ 的最小值即为 $a$ 的阶，记作 $Ord(a)$.**原根**原根的一般定义是：对于群 $G$, $\exist g\in G$, $Ord(g)=|G|$，则 $g$ 是 $G$ 的原根。现在有一个以加法取模为运算，元素为整数的群，容易知道这是一个循环群，单位元是1. 我们约定，如果这样的一个群的模数是 $p$，则其所在的群是 $G_p$.那么如果我们的问题是这样：求多项式系数，同时多项式系数对一个模数 $p$ 取余，显然系数构成一个群 $G_p$. 设 $n=|G|$，容易知道 $g^{p-1}=1$, 则不妨令 $g_n=g^{\frac{p-1}{n}}$, 有 $g_n^n=1$.从这里我们就看出，$g_n$ 和 FFT 中的 $w_n$ 是有一一对应关系的，所以我们只需要将 FFT 的点值取值修改为 $g_n^0,g_n^1,...g_n^{n-1}$ 即可。至于原根如何求出，我们可以找一个 $p-1$ 的质因子 $q$, 则 $g$ 为原根 $\lrArr$ $g^{\frac{p-1}{q}}\neq 1$ （由欧拉定理可证），将 $p-1$ 的质因子逐个找出再判断一下即可。通常题目会要求 $p=119×2^{23}+1=998244353,\ g=3$.> 据说，因为大多数NTT题目都会取更方便造数据的998244353为模数，这就导致很多题一看模数就知道这题是要做NTT。所以后来许多和NTT无关甚至完全不需要取模的题目也会加上一句“对998244353取模”。理解粗浅，还是老老实实看模板吧。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// op = 1 ? DFT : IDFT</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> F[maxn], G[maxn];</span><br><span class="line"><span class="keyword">int</span> r[maxn];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p &amp; <span class="number">1</span>) ans = (ans * a) % mod;</span><br><span class="line">        a = (a * a) % mod;</span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ntt</span><span class="params">(<span class="keyword">int</span> f[], <span class="keyword">int</span> n, <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; r[i]) <span class="built_in">swap</span>(f[i], f[r[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; n; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> wn = <span class="built_in">fpow</span>(op == <span class="number">1</span> ? <span class="number">3</span> : <span class="number">332748118</span>, (mod - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += (mid &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; ++k, w = w * wn % mod) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = f[j + k], y = w * f[j + k + mid] % mod;</span><br><span class="line">                f[j + k] = (x + y) % mod;</span><br><span class="line">                f[j + k + mid] = ((x - y) % mod + mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;F[i]);</span><br><span class="line">        F[i] = (F[i] + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        G[i] = (G[i] + mod) % mod;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;G[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    m += n, n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n &lt;= m) n &lt;&lt;= <span class="number">1</span>, cnt++; <span class="comment">// 补足系数，保证是2的幂次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (cnt - <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// DFT</span></span><br><span class="line">    <span class="built_in">ntt</span>(F, n, <span class="number">1</span>), <span class="built_in">ntt</span>(G, n, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) F[i] = (F[i] * G[i]) % mod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IDFT</span></span><br><span class="line">    <span class="built_in">ntt</span>(F, n, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> inv = <span class="built_in">fpow</span>(n, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, (F[i] * inv) % mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">打死不学数学FLAG系列...</summary>
    
    
    
    <category term="XCPC" scheme="https://eykenis.github.io/categories/XCPC/"/>
    
    
    <category term="FFT" scheme="https://eykenis.github.io/tags/FFT/"/>
    
    <category term="数学" scheme="https://eykenis.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="NTT" scheme="https://eykenis.github.io/tags/NTT/"/>
    
  </entry>
  
</feed>
