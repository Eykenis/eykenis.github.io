<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>2021寒假训练第一周解题报告 | Ekke の Space</title><meta name="keywords" content="早期珍贵资料,DP,gcd,二叉树,背包,高精度"><meta name="author" content="Ekennis,ekennis@outlook.com"><meta name="copyright" content="Ekennis"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Div3杂题。内容包括：gcd数论、01背包、基础dp、高精度、dfs、思维等">
<meta property="og:type" content="article">
<meta property="og:title" content="2021寒假训练第一周解题报告">
<meta property="og:url" content="https://eykenis.github.io/2021/01/29/2021%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83%E7%AC%AC%E4%B8%80%E5%91%A8%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/index.html">
<meta property="og:site_name" content="Ekke の Space">
<meta property="og:description" content="Div3杂题。内容包括：gcd数论、01背包、基础dp、高精度、dfs、思维等">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/20210701162440.png">
<meta property="article:published_time" content="2021-01-28T16:00:00.000Z">
<meta property="article:modified_time" content="2021-07-11T06:11:42.297Z">
<meta property="article:author" content="Ekennis">
<meta property="article:tag" content="早期珍贵资料">
<meta property="article:tag" content="DP">
<meta property="article:tag" content="gcd">
<meta property="article:tag" content="二叉树">
<meta property="article:tag" content="背包">
<meta property="article:tag" content="高精度">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/20210701162440.png"><link rel="shortcut icon" href="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/20210701163204.png"><link rel="canonical" href="https://eykenis.github.io/2021/01/29/2021%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83%E7%AC%AC%E4%B8%80%E5%91%A8%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"TV3DB6RYHK","apiKey":"0e361fa50ef5705da3e38fedfa0fe58c","indexName":"ekke","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '2021寒假训练第一周解题报告',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2021-07-11 14:11:42'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Ekke の Space" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/20210701163204.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">65</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://ekkepic.oss-cn-beijing.aliyuncs.com/img/20210701162440.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Ekke の Space</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">2021寒假训练第一周解题报告</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-01-28T16:00:00.000Z" title="发表于 2021-01-29 00:00:00">2021-01-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-11T06:11:42.297Z" title="更新于 2021-07-11 14:11:42">2021-07-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/">解题报告</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="2021寒假训练第一周解题报告"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><em>前言：换了主题之后WP的傻瓜文本编辑器也没了，所以在<a target="_blank" rel="noopener" href="https://realsaltedfish.com/">RealsaltedFish</a>的指路下搞了个Typora来写Markdown文本。html果然还是太复杂了啊ヽ(￣▽￣)ﾉ</em></p>
<p>正文，首先贴训练链接：<br><a target="_blank" rel="noopener" href="https://vjudge.net/contest/419530">Div3专题</a><br><a target="_blank" rel="noopener" href="https://vjudge.net/contest/419533">DFS/BFS专题（以前练过，应该不会写题解了）</a><br><a target="_blank" rel="noopener" href="https://vjudge.net/contest/419535">DP专题</a><br><a target="_blank" rel="noopener" href="https://vjudge.net/contest/419536">贪心算法专题</a><br><del>好了，贴完链接，惭愧地说我只有Div3专题能写题解，怎么说呢，搜索专题是懒了，贪心是已经很努力在贪了，但是基本上一题能贪一天（是我不够贪心呜呜呜呜），动规的话，打算这周先熟悉好二叉树，下周再看进阶动规，是这样的</del> 我舅要写！舅要写！</p>
<p>因为水题不在少数（<del>当然完全不会做的也更多</del>)，所以只贴一部分题。</p>
<p>专题训练结束后贴一贴其他题题解，也算回顾一下。</p>
<hr>
<h1 id="Div3专题"><a href="#Div3专题" class="headerlink" title="Div3专题"></a>Div3专题</h1><h2 id="E-最大公约数"><a href="#E-最大公约数" class="headerlink" title="E.最大公约数"></a>E.最大公约数</h2><p><a target="_blank" rel="noopener" href="https://vjudge.net/contest/419530#problem/E">E - Cake</a></p>
<p><strong>描述</strong></p>
<p>一次生日Party可能有p人或者q人参加,现准备有一个大蛋糕.问最少要将蛋糕切成多少块(每块大小不一定相等),才能使p人或者q人出席的任何一种情况,都能平均将蛋糕分食.</p>
<p><strong>输入</strong></p>
<p>每行有两个数p和q.</p>
<p><strong>输出</strong></p>
<p>输出最少要将蛋糕切成多少块.</p>
<p><strong>样例输入</strong></p>
<p>2 3</p>
<p><strong>样例输出</strong></p>
<p>4</p>
<p><strong>思路&amp;题解</strong></p>
<p>看到题目首先没有理解题意，在蛋糕可以不等大的情况下平均分食是指每个人可以选择不同数量的蛋糕，以达到每个人拥有的蛋糕总量都一样。</p>
<p>但是到这里的时候我没思路了。没有思路就先做不完全归纳，画圆，不难发现当p和q都为偶数时，只需要将蛋糕分成 <code>max&#123;p, q&#125;</code> 个就可以了。接着归纳其他情况，例如p、q为3、5时，先将蛋糕3等分，再想办法5等分，可以发现直接多切2刀是无论如何也无法5等分的，于是多切4刀，总共7刀。推导到这里都还好，但是随着数量增加，仍然只能靠感觉，发现不了规律。于是回头，再次审视我画的这圆圆的蛋糕。<br>不如，将含有3等分线的蛋糕看做一个轮盘，再将含有5等分线的蛋糕看做一个轮盘，让他们重叠之后旋转。旋转过程中，要保证切的刀数最小，也就是让有些刀尽量即能为3等分做贡献，也为5等分做贡献。于是保证尽可能多的等分线重合。这样，3和5最多有一个线重合。再尝试3和7，最多一条线重合；6和2，最多2条线……稍微思考了一下，一个一个数p的等分线，那么应该是每前进若干个<code>1/p</code> 的时候，就会有一条线与 q 的一个等分线重合， 也就是达到了 <code>1/q</code>. 那么<code>1/p</code> 和 <code>1/q</code> 就应该有比例关系，想起了D题的卫星相遇周期，于是发现，这tm是求gcd（最大公约数）啊！</p>
<p>得到重合线最多个数是<code>gcd（p，q）</code>.</p>
<p><strong>代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a + b - gcd(a, b));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="K-01背包"><a href="#K-01背包" class="headerlink" title="K.01背包"></a>K.01背包</h2><p><a target="_blank" rel="noopener" href="https://vjudge.net/contest/419530#problem/K">K - I NEED A OFFER!</a></p>
<p><strong>描述</strong></p>
<p><del>首先吐槽出题人的英语水平， 看看题目名吧</del></p>
<p>Speakless很早就想出国，现在他已经考完了所有需要的考试，准备了所有要准备的材料，于是，便需要去申请学校了。要申请国外的任何大学，你都要交纳一定的申请费用，这可是很惊人的。Speakless没有多少钱，总共只攒了n万美元。他将在m个学校中选择若干的（当然要在他的经济承受范围内）。每个学校都有不同的申请费用a（万美元），并且Speakless估计了他得到这个学校offer的可能性b。不同学校之间是否得到offer不会互相影响。“I NEED A OFFER”，他大叫一声。帮帮这个可怜的人吧，帮助他计算一下，他可以收到至少一份offer的最大概率。（如果Speakless选择了多个学校，得到任意一个学校的offer都可以）。</p>
<p><strong>输入</strong></p>
<p>输入有若干组数据，每组数据的第一行有两个正整数<code>n,m(0&lt;=n&lt;=10000,0&lt;=m&lt;=10000)</code><br>后面的m行，每行都有两个数据ai(整型),bi(实型)分别表示第i个学校的申请费用和可能拿到offer的概率。<br>输入的最后有两个0。</p>
<p><strong>输出</strong></p>
<p>每组数据都对应一个输出，表示Speakless可能得到至少一份offer的最大概率。用百分数表示，精确到小数点后一位。</p>
<p><strong>样例输入</strong></p>
<p>10    3</p>
<p>4    0.1</p>
<p>4    0.2</p>
<p>5    0.3</p>
<p>0    0</p>
<p><strong>样例输出</strong></p>
<p>44.0%</p>
<p><strong>题解</strong></p>
<p>01背包问题。因为至少得到一份offer的概率不能累计，所以将输入中得到offer的概率改为得不到offer的概率存储，然后建立dp数组。定义dp[i]为申请完第0 ~ i 个学校得不到offer的最小概率。则得到状态转移方程：</p>
<script type="math/tex; mode=display">
dp[i] = min(dp[j], dp[j - a[i]] * b[i]),j - a[i]≥0,j<i</script><p>.其中<code>a[i]</code>是第i个学校的申请费用，<code>b[i]</code>是第i个学校不被录取的概率。（完全就是背包问题嘛）</p>
<p>最后用 <code>1 - min(dp[i])</code> 就是问题答案。</p>
<p><strong>代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">school</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">double</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">double</span> dp[maxn];<span class="comment">//dp[i]：对于容量i，得到的最小被拒绝概率 </span></span><br><span class="line"><span class="comment">//状态转移：dp[i] = min(dp[i], dp[i - a[i]] * b[i])</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//01背包</span></span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m &amp;&amp; (n || m))&#123;</span><br><span class="line">	school a[m];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%lf&quot;</span>, &amp;a[i].a, &amp;a[i].b);</span><br><span class="line">		a[i].b = <span class="number">1</span> - a[i].b;<span class="comment">//转化成得不到offer的概率，然后所有概率相乘，求个最小的 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) dp[i] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = n; j &gt;= a[i].a; --j)&#123;</span><br><span class="line">			dp[j] = <span class="built_in">min</span>(dp[j], dp[j - a[i].a] * a[i].b);</span><br><span class="line">			ans = <span class="built_in">min</span>(ans, dp[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.1lf%%\n&quot;</span>, <span class="number">100</span> * (<span class="number">1</span> - ans));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="O-高精"><a href="#O-高精" class="headerlink" title="O.高精"></a>O.高精</h2><p><a target="_blank" rel="noopener" href="https://vjudge.net/contest/419530#problem/O">O - N!</a></p>
<p>==<strong>贴这题只是想提醒一下自己，高精不一定非得写板子写类啊，这题直接用数组作乘法就ok了，不需要额外的对象化。</strong>==</p>
<h2 id="V-树的遍历"><a href="#V-树的遍历" class="headerlink" title="V.树的遍历"></a>V.树的遍历</h2><p><a target="_blank" rel="noopener" href="https://vjudge.net/contest/419530#problem/V">V - Binary Tree Traversals</a></p>
<p><strong>描述</strong></p>
<p>A binary tree is a finite set of vertices that is either empty or consists of a root r and two disjoint binary trees called the left and right subtrees. There are three most important ways in which the vertices of a binary tree can be systematically traversed or ordered. They are preorder, inorder and postorder. Let T be a binary tree with root r and subtrees T1,T2.</p>
<p>In a preorder traversal of the vertices of T, we visit the root r followed by visiting the vertices of T1 in preorder, then the vertices of T2 in preorder.</p>
<p>In an inorder traversal of the vertices of T, we visit the vertices of T1 in inorder, then the root r, followed by the vertices of T2 in inorder.</p>
<p>In a postorder traversal of the vertices of T, we visit the vertices of T1 in postorder, then the vertices of T2 in postorder and finally we visit r.</p>
<p>Now you are given the preorder sequence and inorder sequence of a certain binary tree. Try to find out its postorder sequence.<br><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/20210701162213.png" alt=""><br><strong>输入</strong></p>
<p>The input contains several test cases. The first line of each test case contains a single integer n (1&lt;=n&lt;=1000), the number of vertices of the binary tree. Followed by two lines, respectively indicating the preorder sequence and inorder sequence. You can assume they are always correspond to a exclusive binary tree.</p>
<p><strong>输出</strong></p>
<p>For each test case print a single line specifying the corresponding postorder sequence.</p>
<p><strong>样例输入</strong></p>
<p>9<br>1 2 4 7 3 5 8 9 6<br>4 7 2 1 8 5 9 3 6</p>
<p><strong>样例输出</strong></p>
<p>7 4 2 8 9 5 6 3 1</p>
<p><strong>题解</strong></p>
<p>题意：给定一棵树的先序遍历和中序遍历，求后序遍历。首先通过先序遍历和中序遍历构建树。</p>
<p>先序遍历的第一个数就是树根，在中序遍历中找出这个树根，则树根左右的子序列就是左右子树的中序遍历，而先序遍历的树根之后紧跟着左右子树的先序遍历，由此确定左右子树，以此递归下去。</p>
<p>建树完成后，通过深度优先搜索得到后序遍历. 后序遍历的搜索顺序是：左子树-&gt;右子树-&gt;根.</p>
<p><strong>代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1050</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="comment">//给定先序，中序遍历，求后序遍历</span></span><br><span class="line"><span class="comment">//先序遍历的第一个为根，然后在中序遍历中找到根，构建左右子树</span></span><br><span class="line"><span class="keyword">int</span> pre[maxn], in[maxn], l[maxn], r[maxn], f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> *a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">		~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l1, <span class="keyword">int</span> r1, <span class="keyword">int</span> l2, <span class="keyword">int</span> r2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l1 &gt; r1 || l2 &gt; r2) </span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> root = pre[l1];</span><br><span class="line">	<span class="keyword">int</span> p = l2;</span><br><span class="line">	<span class="keyword">while</span>(in[p] != root) p++;</span><br><span class="line">	<span class="keyword">int</span> cnt = p - l2;<span class="comment">//左子树节点个数 </span></span><br><span class="line">	l[root] = <span class="built_in">build</span>(l1 + <span class="number">1</span>, l1 + cnt, l2, l2 + cnt - <span class="number">1</span>);</span><br><span class="line">	r[root] = <span class="built_in">build</span>(l1 + cnt + <span class="number">1</span>, r1, p + <span class="number">1</span>, r2);</span><br><span class="line">	f[l[root]] = root;</span><br><span class="line">	f[r[root]] = root;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="comment">//后序遍历函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_dfs</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l[root]) <span class="built_in">post_dfs</span>(l[root]);</span><br><span class="line">	<span class="keyword">if</span>(r[root]) <span class="built_in">post_dfs</span>(r[root]);</span><br><span class="line">	ans.<span class="built_in">push_back</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; n)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(l, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(l));</span><br><span class="line">		<span class="built_in">memset</span>(r, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(r));</span><br><span class="line">		<span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(pre));</span><br><span class="line">		<span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(in));</span><br><span class="line">		<span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">		ans.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">read</span>(pre);</span><br><span class="line">		<span class="built_in">read</span>(in);</span><br><span class="line">		<span class="built_in">build</span>(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">int</span> start = pre[<span class="number">0</span>];</span><br><span class="line">		<span class="built_in">post_dfs</span>(start);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">			cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans[ans.<span class="built_in">size</span>() - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>其它</strong></p>
<p>做本题的时候紫书进度正好在树这一章节，刚学完从中序和后序遍历求先序遍历。所以这题是此时此刻再合适不过的练习题了~</p>
<h2 id="W-思维"><a href="#W-思维" class="headerlink" title="W.思维"></a>W.思维</h2><p><a target="_blank" rel="noopener" href="https://vjudge.net/contest/419530#problem/W">W - Friend</a><br><strong>描述</strong></p>
<p>Friend number are defined recursively as follows.<br>(1) numbers 1 and 2 are friend number;<br>(2) if a and b are friend numbers, so is ab+a+b;<br>(3) only the numbers defined in (1) and (2) are friend number.<br>Now your task is to judge whether an integer is a friend number.</p>
<p><strong>输入</strong></p>
<p>There are several lines in input, each line has a nunnegative integer a, 0&lt;=a&lt;=2^30.</p>
<p><strong>输出</strong></p>
<p>For the number a on each line of the input, if a is a friend number, output “YES!”, otherwise output “NO!”.</p>
<p><strong>样例输入</strong></p>
<p>3</p>
<p>13121</p>
<p>12131</p>
<p><strong>样例输出</strong></p>
<p>YES!</p>
<p>YES!</p>
<p>NO!</p>
<p><strong>题解</strong></p>
<p>像E - Cake那题一样，先不完全归纳一下，1和2是，那么<code>2 + 2 + 1 = 5</code>也是；紧接着 11、 17也是。到这里后我又推了几个，没找着规律。于是回头看公式，<code>ab + a + b</code>，拆成<code>(a + 1)(b + 1) - 1</code>. 发现所有的<code>(a + 1)(b + 1)</code>均为6的倍数！但是特别注意这里a和b也可能相等，而都取1时结果为4、都取2时结果为9，说明3和8也是Friend Number. 进一步，都取3，那<code>(a + 1)(b + 1)</code>的值就是16. 再看取8，得到80.</p>
<p>若干数据之后得出：如果一个数是Friend Number，那么这个数 - 1后必定只有2和3这两个素因子.</p>
<p>做题时不知道是如何证明的，总之稀里糊涂一次AC了，之后看题解知道了证明过程：</p>
<p>设n是不为1也不为2的friend number，那么存在两个friend number a和b，使得 <code>n = ab + a + b</code>.</p>
<p>因式分解得到</p>
<script type="math/tex; mode=display">
n + 1 = (a + 1)(b + 1)</script><p>既然1和2是最小的两个friend number，而n + 1也仅由其他的friend number决定，不难知道n + 1一定是由2和3乘出的。</p>
<p><strong>代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;NO!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(n % <span class="number">2</span> == <span class="number">0</span>) n /= <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span>(n % <span class="number">3</span> == <span class="number">0</span>) n /= <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;YES!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; n)&#123;</span><br><span class="line">		<span class="built_in">process</span>(n + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="DP专题"><a href="#DP专题" class="headerlink" title="DP专题"></a>DP专题</h1><h2 id="A-前缀-dp"><a href="#A-前缀-dp" class="headerlink" title="A.前缀 + dp"></a>A.前缀 + dp</h2><p><a target="_blank" rel="noopener" href="https://vjudge.net/contest/419535#problem/A">A题链接</a></p>
<p><strong>描述</strong></p>
<p>Now I think you have got an AC in Ignatius.L’s “Max Sum” problem. To be a brave ACMer, we always challenge ourselves to more difficult problems. Now you are faced with a more difficult problem.</p>
<p>Given a consecutive number sequence S<em>1</em>, S<em>2</em>, S<em>3</em>, S<em>4</em> … S<em>x</em>, … S<em>n</em> (1 ≤ x ≤ n ≤ 1,000,000, -32768 ≤ S<em>x</em> ≤ 32767). We define a function sum(i, j) = S<em>i</em> + … + S<em>j</em> (1 ≤ i ≤ j ≤ n).</p>
<p>Now given an integer m (m &gt; 0), your task is to find m pairs of i and j which make sum(i<em>1</em>, j<em>1</em>) + sum(i<em>2</em>, j<em>2</em>) + sum(i<em>3</em>, j<em>3</em>) + … + sum(i<em>m</em>, j<em>m</em>) maximal (i<em>x</em> ≤ i<em>y</em> ≤ j<em>x</em> or i<em>x</em> ≤ j<em>y</em> ≤ j<em>x</em> is not allowed).</p>
<p>But I`m lazy, I don’t want to write a special-judge module, so you don’t have to output m pairs of i and j, just output the maximal summation of sum(i<em>x</em>, j<em>x</em>)(1 ≤ x ≤ m) instead. ^_^</p>
<p><strong>输入</strong></p>
<p>Each test case will begin with two integers m and n, followed by n integers S<em>1</em>, S<em>2</em>, S<em>3</em> … S<em>n</em>.<br>Process to the end of file.</p>
<p><strong>输出</strong></p>
<p>Output the maximal summation described above in one line.</p>
<p><strong>样例输入</strong></p>
<p>1    3    1    2    3</p>
<p>2    6    -1    4    -2    3    -2    3</p>
<p><strong>样例输出</strong></p>
<p>6</p>
<p>8</p>
<p><strong>题意</strong></p>
<p>给定一个长度为n的数组,从中选m个不相交的子序列,求得到的子序列最大和为多少.</p>
<p><strong>分析</strong></p>
<p>利用<code>dp</code>拆解问题——<code>dp[i][j]</code>表示前j个数分成j组得到的最大和，且保证a[i]在最后一个子序列中。其中i&lt;n，i≤j≤m.</p>
<p>如何进行状态转移？试想，要把dp[i]算出，且保证a[i]在子序列中，只有两种情况：一种是让a[i]自成一个子序列，二是把a[i]加入前面i-1个数的最后一个子序列中。那么状态转移方程为$dp[i][j] = max(dp[i - 1][j - 1], dp[i - 1][j]) + a[i]$.然后记录dp数组最大值即可。</p>
<p>但题目提示数据规模在百万级别，开数组会内存超限。于是二维数组存dp不可行了。尝试优化，将dp数组的第二维存入一个前缀数组，这样将空间复杂度从<em>O(n^2^</em>)降低到了<em>O(2n)</em>，于是设dp[i]为前i个数的答案，然后有一个记录数组fdp，每次i增加时，fdp数组都存储前面i-1个元素中所要求的<code>当前子序列个数-1</code>个子序列最大子段和。到这里无法直接进行划分，故可以外套循环从1至m，依次求出1划分至m划分的答案。</p>
<p>状态转移方程：$dp[i] = max(dp[i-1],fdp[i-1])+a[i]$.</p>
<p>此处dp[i-1]即a[i]接入最后一个序列的情况，fdp[i-1]为a[i]单独成子序列的情况。</p>
<p>特别注意上述方程没有确定子序列个数，需要从1遍历至m不断更新。</p>
<p><del>^fdp是我瞎取的名字啦^</del></p>
<p><strong>代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="keyword">int</span> fdp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; m &gt;&gt; n)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(fdp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(fdp));</span><br><span class="line">		<span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">		<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];</span><br><span class="line">		<span class="comment">//	dp[i][j]表示前i个数，分j组</span></span><br><span class="line">		<span class="comment">//	fdp存前缀 </span></span><br><span class="line">		<span class="keyword">int</span> tmp;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">			tmp = -INF;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= n; ++j)&#123;</span><br><span class="line">				dp[j] = <span class="built_in">max</span>(dp[j - <span class="number">1</span>], fdp[j - <span class="number">1</span>]) + a[j];</span><br><span class="line">				fdp[j - <span class="number">1</span>] = tmp;</span><br><span class="line">				tmp = <span class="built_in">max</span>(dp[j], tmp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-排序-DP"><a href="#C-排序-DP" class="headerlink" title="C.排序 + DP"></a>C.排序 + DP</h2><p><a target="_blank" rel="noopener" href="https://vjudge.net/contest/419535#problem/C">C题链接</a></p>
<p><strong>描述</strong></p>
<p>A group of researchers are designing an experiment to test the IQ of a monkey. They will hang a banana at the roof of a building, and at the mean time, provide the monkey with some blocks. If the monkey is clever enough, it shall be able to reach the banana by placing one block on the top another to build a tower and climb up to get its favorite food.</p>
<p>The researchers have n types of blocks, and an unlimited supply of blocks of each type. Each type-i block was a rectangular solid with linear dimensions (xi, yi, zi). A block could be reoriented so that any two of its three dimensions determined the dimensions of the base and the other dimension was the height.</p>
<p>They want to make sure that the tallest tower possible by stacking blocks can reach the roof. The problem is that, in building a tower, one block could only be placed on top of another block as long as the two base dimensions of the upper block were both strictly smaller than the corresponding base dimensions of the lower block because there has to be some space for the monkey to step on. This meant, for example, that blocks oriented to have equal-sized bases couldn’t be stacked.</p>
<p>Your job is to write a program that determines the height of the tallest tower the monkey can build with a given set of blocks.</p>
<p><strong>输入</strong></p>
<p>The input file will contain one or more test cases. The first line of each test case contains an integer n,<br>representing the number of different blocks in the following data set. The maximum value for n is 30.<br>Each of the next n lines contains three integers representing the values xi, yi and zi.<br>Input is terminated by a value of zero (0) for n.</p>
<p><strong>输出</strong></p>
<p>For each test case, print one line containing the case number (they are numbered sequentially starting from 1) and the height of the tallest possible tower in the format “Case case: maximum height = height”.</p>
<p><strong>Sample Input</strong></p>
<p>1<br>10 20 30<br>2<br>6 8 10<br>5 5 5<br>7<br>1 1 1<br>2 2 2<br>3 3 3<br>4 4 4<br>5 5 5<br>6 6 6<br>7 7 7<br>5<br>31 41 59<br>26 53 58<br>97 93 23<br>84 62 64<br>33 83 27<br>0</p>
<p><strong>Sample Output</strong></p>
<p>Case 1: maximum height = 40<br>Case 2: maximum height = 21<br>Case 3: maximum height = 28<br>Case 4: maximum height = 342</p>
<p><strong>题意</strong></p>
<p>给n种长方体，每种长方体无限个，将他们摞起来，保证下面的长&amp;宽分别严格大于上面的长&amp;宽。其中每一个长方体都可以改变朝向。</p>
<p><strong>分析</strong></p>
<p>因为可以换朝向，所以把三个数字对长-宽-高的排列全放进去（也就是每个输入其实相当于放了6种长方体进数组）。直接设<code>dp[i][j]</code>为把第i种放在第j层的答案，不过由于状态转移方程一时半会写不出+感觉时间空间都比较复杂，于是摒弃了这种设计。另起炉灶：</p>
<p>先贪心排序，不考虑高，按长更大优先排序，长相等的按宽更大优先排序，这样数组从前往后可以保证答案的长方体序列的顺序一定是从前往后，不会出现交叉。然后设dp[i]为前i个长方体的答案，类似于求递增子列的最大和。对每个dp[i]，枚举dp[0]~dp[i-1]，如果第i个可以摞在第j个上面，且摞起来之后的高度大于原本的dp[i]，就更新dp[i]。状态转移方程为$dp[i] = max(dp[i], dp[j] + height[i])(j&lt;i,length[i]&lt;length[j],width[i]&lt;width[j])$.</p>
<p>两层循环，平方复杂度。</p>
<p><strong>代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">300</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">block</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x, y, z;<span class="comment">//长宽高 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(block b1, block b2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b1.x != b2.x) <span class="keyword">return</span> b1.x &gt; b2.x;</span><br><span class="line">	<span class="keyword">return</span> b1.y &gt; b2.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//不会又被卡longlong吧... </span></span><br><span class="line"><span class="comment">//	ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="comment">//	cin.tie(0);</span></span><br><span class="line"><span class="comment">//	freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="comment">//	freopen(&quot;out.o&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="comment">//文件忘记关了你！ </span></span><br><span class="line"><span class="comment">//文件关了也不对！！！！！！！！！！！ </span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!n) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">int</span> a, b, c;</span><br><span class="line">		<span class="keyword">int</span> dp[maxn];</span><br><span class="line">		<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">		vector&lt;block&gt; v;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; ++u)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">			v.<span class="built_in">push_back</span>(&#123;a, b, c&#125;);</span><br><span class="line">			v.<span class="built_in">push_back</span>(&#123;a, c, b&#125;);</span><br><span class="line">			v.<span class="built_in">push_back</span>(&#123;b, a ,c&#125;);</span><br><span class="line">			v.<span class="built_in">push_back</span>(&#123;b, c, a&#125;);</span><br><span class="line">			v.<span class="built_in">push_back</span>(&#123;c, a, b&#125;);</span><br><span class="line">			v.<span class="built_in">push_back</span>(&#123;c, b, a&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmp);</span><br><span class="line">		dp[<span class="number">0</span>] = v[<span class="number">0</span>].z;</span><br><span class="line">		ans = dp[<span class="number">0</span>];</span><br><span class="line">		<span class="comment">//也可能是没算第1个啊 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">			<span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)&#123;</span><br><span class="line">				<span class="keyword">if</span>(v[i].x &lt; v[j].x &amp;&amp; v[i].y &lt; v[j].y)&#123;</span><br><span class="line">					tmp = <span class="built_in">max</span>(tmp, dp[j]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			dp[i] = v[i].z + tmp;</span><br><span class="line">			ans = <span class="built_in">max</span>(dp[i], ans);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Case %lld: maximum height = %lld\n&quot;</span>, ++kase, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="J-排序-DP"><a href="#J-排序-DP" class="headerlink" title="J.排序 + DP"></a>J.排序 + DP</h2><p>结构体先排序再dp，和C一模一样的套路，不过多了记录答案的具体序列，用一个类链表的数组记录序列前一个的位置即可，只贴代码和链接。</p>
<p><a target="_blank" rel="noopener" href="https://vjudge.net/contest/419535#problem/J">J题链接</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mouse</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> w, s, id;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> mouse &amp;another)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>-&gt;w &lt; another.w &amp;&amp; <span class="keyword">this</span>-&gt;s &gt; another.s) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//按体重升序，速度降序先排个序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(mouse m1, mouse m2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(m1.w != m2.w) <span class="keyword">return</span> m1.w &lt; m2.w;</span><br><span class="line">	<span class="keyword">return</span> m1.s &lt; m2.s;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	vector&lt;mouse&gt; v;</span><br><span class="line">	<span class="keyword">int</span> w, s;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; w &gt;&gt; s)&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(&#123;w, s, v.<span class="built_in">size</span>()&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> n = v.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">int</span> pre[n], dp[n];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) pre[i] = inf;</span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">		dp[i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(v[j] &lt; v[i])&#123;</span><br><span class="line"><span class="comment">//				dp[i] = max(dp[j] + 1, dp[i]);</span></span><br><span class="line">				<span class="keyword">if</span>(dp[j] + <span class="number">1</span> &gt; dp[i])&#123;</span><br><span class="line">					dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">					pre[i] = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	stack&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">	<span class="keyword">int</span> maxdp = <span class="number">1</span>, maxi = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(dp[i] &gt; maxdp)&#123;</span><br><span class="line">			maxdp = dp[i];</span><br><span class="line">			maxi = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; dp[maxi] &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		ans.<span class="built_in">push</span>(v[maxi].id + <span class="number">1</span>);</span><br><span class="line">		maxi = pre[maxi];</span><br><span class="line">	&#125;<span class="keyword">while</span>(maxi != inf);</span><br><span class="line">	<span class="keyword">while</span>(!ans.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		cout &lt;&lt; ans.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">		ans.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="L-最大公共子序列"><a href="#L-最大公共子序列" class="headerlink" title="L.最大公共子序列"></a>L.最大公共子序列</h2><p>（以后题解的题面就直接复制OJ上的吧，自己打题面的格式没啥意义哈哈哈）</p>
<p><strong>description</strong></p>
<p>A subsequence of a given sequence is the given sequence with some elements (possible none) left out. Given a sequence X = &lt; x1, x2, …, xm &gt; another sequence Z = &lt; z1, z2, …, zk &gt; is a subsequence of X if there exists a strictly increasing sequence &lt; i1, i2, …, ik &gt; of indices of X such that for all j = 1,2,…,k, xij = zj. For example, Z = &lt; a, b, f, c &gt; is a subsequence of X = &lt; a, b, c, f, b, c &gt; with index sequence &lt; 1, 2, 4, 6 &gt;. Given two sequences X and Y the problem is to find the length of the maximum-length common subsequence of X and Y.</p>
<p><strong>Input</strong></p>
<p>The program input is from the std input. Each data set in the input contains two strings representing the given sequences. The sequences are separated by any number of white spaces. The input data are correct.</p>
<p><strong>Output</strong></p>
<p>For each set of data the program prints on the standard output the length of the maximum-length common subsequence from the beginning of a separate line.</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abcfbc         abfcab</span><br><span class="line">programming    contest </span><br><span class="line">abcd           mnp</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">2</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p><strong>题意</strong></p>
<p>求两个字母字符串的最大公共子序列（注意不是子串）。</p>
<p><strong>分析</strong></p>
<p>用二维表存储dp结果。<code>dp[i][j]</code>表示第一个串的前i个和第二个串的前j个构成的子答案。</p>
<p>如果a串的第i个和b串的第j个字母相同，那么<code>dp[i][j] = dp[i - 1][j - 1] + 1</code>.</p>
<p>否则的话，只能继承之前的最佳答案了，<code>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])</code>.</p>
<p><strong>代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string a, b;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; a &gt;&gt; b)&#123;</span><br><span class="line">		<span class="keyword">int</span> dp[a.<span class="built_in">size</span>() + <span class="number">1</span>][b.<span class="built_in">size</span>() + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b.<span class="built_in">size</span>(); ++j)&#123;</span><br><span class="line">				<span class="keyword">if</span>(a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">				ans = <span class="built_in">max</span>(ans, dp[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Q-二维DP"><a href="#Q-二维DP" class="headerlink" title="Q.二维DP"></a>Q.二维DP</h2><p><strong>description</strong></p>
<p>Today is army day, but the servicemen are busy with the phalanx for the celebration of the 60th anniversary of the PRC.<br>A phalanx is a matrix of size n<em>n, each element is a character (a~z or A~Z), standing for the military branch of the servicemen on that position.<br>For some special requirement it has to find out the size of the max symmetrical sub-array. And with no doubt, the Central Military Committee gave this task to ALPCs.<br>A symmetrical matrix is such a matrix that it is symmetrical by the “left-down to right-up” line. The element on the corresponding place should be the same. For example, here is a 3</em>3 symmetrical matrix:<br>cbx<br>cpb<br>zcc</p>
<p><strong>Input</strong></p>
<p>There are several test cases in the input file. Each case starts with an integer n (0&lt;n&lt;=1000), followed by n lines which has n character. There won’t be any blank spaces between characters or the end of line. The input file is ended with a 0.</p>
<p><strong>Output</strong></p>
<p>Each test case output one line, the size of the maximum symmetrical sub- matrix.</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">abx</span><br><span class="line">cyb</span><br><span class="line">zca</span><br><span class="line">4</span><br><span class="line">zaba</span><br><span class="line">cbab</span><br><span class="line">abbc</span><br><span class="line">cacq</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p><strong>题意</strong></p>
<p>给一个字符方阵，把副对角线当对称轴，求最大的对称子方阵。</p>
<p><strong>分析</strong></p>
<p>设<code>dp[i][j]</code>表示<code>a[i][j]</code>为某个对称方阵左下角的字符时最大对称子方阵的大小。由于自己肯定是个对称方阵，初始化所有的<code>dp[i][j]</code>为1.</p>
<p>接着如果<code>dp[i-1][j+1]</code>为k，那么我们要检查<code>a[i][j]</code>上面那一列和右边那一行是否分别相等即可。检查1到k个，每次符合就<code>dp[i][j]++</code>，不符合就<code>break</code>.</p>
<p><strong>代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> a[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; n &amp;&amp; n)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">				cin &gt;&gt; a[i][j];</span><br><span class="line">				dp[i][j] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span>; ++j)&#123;</span><br><span class="line">				<span class="comment">//查对应行列.</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; i - x &gt;= <span class="number">0</span> &amp;&amp; j + x &lt; n &amp;&amp; x &lt;= dp[i - <span class="number">1</span>][j + <span class="number">1</span>]; ++x)&#123;</span><br><span class="line">					<span class="keyword">if</span>(a[i - x][j] == a[i][j + x])&#123;</span><br><span class="line">						dp[i][j]++;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				ans = <span class="built_in">max</span>(dp[i][j], ans);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:ekennis@outlook.com">Ekennis</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://eykenis.github.io/2021/01/29/2021%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83%E7%AC%AC%E4%B8%80%E5%91%A8%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/">https://eykenis.github.io/2021/01/29/2021%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83%E7%AC%AC%E4%B8%80%E5%91%A8%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://eykenis.github.io" target="_blank">Ekke の Space</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%97%A9%E6%9C%9F%E7%8F%8D%E8%B4%B5%E8%B5%84%E6%96%99/">早期珍贵资料</a><a class="post-meta__tags" href="/tags/DP/">DP</a><a class="post-meta__tags" href="/tags/gcd/">gcd</a><a class="post-meta__tags" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a><a class="post-meta__tags" href="/tags/%E8%83%8C%E5%8C%85/">背包</a><a class="post-meta__tags" href="/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/">高精度</a></div><div class="post_share"><div class="social-share" data-image="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/20210701162440.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/02/02/%E8%BD%BB/"><img class="prev-cover" src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/20210701162121.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">轻</div></div></a></div><div class="next-post pull-right"><a href="/2021/01/25/%E6%A0%87%E9%A2%98%E8%A2%AB%E6%A2%A6%E6%B8%B8%E7%9A%84%E6%88%91%E5%90%83%E4%BA%86/"><img class="next-cover" src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/20210701162453.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">标题被梦游的我吃了</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/11/30/20-11-29练习赛/" title="20.11.29练习赛"><img class="cover" src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/20210701163108.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-30</div><div class="title">20.11.29练习赛</div></div></a></div><div><a href="/2020/12/15/20-12-13-ICPC上海记/" title="20.12.13 ICPC上海记"><img class="cover" src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/preview-e1611895471366.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-15</div><div class="title">20.12.13 ICPC上海记</div></div></a></div><div><a href="/2020/12/07/20-12-6-GDUT新生赛/" title="20.12.6 GDUT新生赛"><img class="cover" src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/20210701163156.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-07</div><div class="title">20.12.6 GDUT新生赛</div></div></a></div><div><a href="/2020/12/01/20-11-30练习赛/" title="20.11.30练习赛"><img class="cover" src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/20210701163149.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-01</div><div class="title">20.11.30练习赛</div></div></a></div><div><a href="/2020/12/07/20-12-6练习赛/" title="20.12.6练习赛"><img class="cover" src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/20210709144124.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-07</div><div class="title">20.12.6练习赛</div></div></a></div><div><a href="/2020/12/08/20-12-7练习赛/" title="20.12.7练习赛"><img class="cover" src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/20210701163216.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-08</div><div class="title">20.12.7练习赛</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/20210701163204.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Ekennis</div><div class="author-info__description">希望成为一名合格的Technical Artist.</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">65</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Eykenis" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:ekennis@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>音乐</span></div><div class="announcement_content"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=240 height=86 src="//music.163.com/outchain/player?type=2&id=476081899&auto=0&height=66"></iframe></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Div3%E4%B8%93%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">Div3专题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#E-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">E.最大公约数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#K-01%E8%83%8C%E5%8C%85"><span class="toc-number">1.2.</span> <span class="toc-text">K.01背包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#O-%E9%AB%98%E7%B2%BE"><span class="toc-number">1.3.</span> <span class="toc-text">O.高精</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#V-%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.4.</span> <span class="toc-text">V.树的遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#W-%E6%80%9D%E7%BB%B4"><span class="toc-number">1.5.</span> <span class="toc-text">W.思维</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DP%E4%B8%93%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">DP专题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#A-%E5%89%8D%E7%BC%80-dp"><span class="toc-number">2.1.</span> <span class="toc-text">A.前缀 + dp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E6%8E%92%E5%BA%8F-DP"><span class="toc-number">2.2.</span> <span class="toc-text">C.排序 + DP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#J-%E6%8E%92%E5%BA%8F-DP"><span class="toc-number">2.3.</span> <span class="toc-text">J.排序 + DP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#L-%E6%9C%80%E5%A4%A7%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">2.4.</span> <span class="toc-text">L.最大公共子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-%E4%BA%8C%E7%BB%B4DP"><span class="toc-number">2.5.</span> <span class="toc-text">Q.二维DP</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2922/12/31/%E3%80%8AEarth-OL-2022%E3%80%8B%E6%88%90%E5%B0%B1%E5%88%97%E8%A1%A8/" title="《Earth OL 2022》成就列表"><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/Cache_-612dd93facc60384.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《Earth OL 2022》成就列表"/></a><div class="content"><a class="title" href="/2922/12/31/%E3%80%8AEarth-OL-2022%E3%80%8B%E6%88%90%E5%B0%B1%E5%88%97%E8%A1%A8/" title="《Earth OL 2022》成就列表">《Earth OL 2022》成就列表</a><time datetime="2922-12-31T14:37:07.000Z" title="发表于 2922-12-31 22:37:07">2922-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/04/KERenderer-%E2%80%94%E2%80%94%E6%88%91%E7%9A%84%E8%BD%AF%E6%B8%B2%E5%BC%80%E5%9D%91%E5%95%A6/" title="KERenderer ——我的软渲开坑啦"><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/sample.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="KERenderer ——我的软渲开坑啦"/></a><div class="content"><a class="title" href="/2022/04/04/KERenderer-%E2%80%94%E2%80%94%E6%88%91%E7%9A%84%E8%BD%AF%E6%B8%B2%E5%BC%80%E5%9D%91%E5%95%A6/" title="KERenderer ——我的软渲开坑啦">KERenderer ——我的软渲开坑啦</a><time datetime="2022-04-04T02:25:51.000Z" title="发表于 2022-04-04 10:25:51">2022-04-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/10/physical-based-renderring/" title="基于物理的渲染（PBR）详解"><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/20220315090910.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于物理的渲染（PBR）详解"/></a><div class="content"><a class="title" href="/2022/03/10/physical-based-renderring/" title="基于物理的渲染（PBR）详解">基于物理的渲染（PBR）详解</a><time datetime="2022-03-10T13:33:58.000Z" title="发表于 2022-03-10 21:33:58">2022-03-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/24/Use-Mirai-in-ur-ECS-server/" title="在 ECS 服务器（Ubuntu）上使用 Mirai 机器人"><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/20220315091110.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="在 ECS 服务器（Ubuntu）上使用 Mirai 机器人"/></a><div class="content"><a class="title" href="/2022/02/24/Use-Mirai-in-ur-ECS-server/" title="在 ECS 服务器（Ubuntu）上使用 Mirai 机器人">在 ECS 服务器（Ubuntu）上使用 Mirai 机器人</a><time datetime="2022-02-24T11:01:20.000Z" title="发表于 2022-02-24 19:01:20">2022-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/23/Bishoujo-Mangekyo-Tsumi-to-Batsu-no-Shoujo/" title="万字长评《美少女万华镜 - 罪与罚的少女》"><img src="https://ekkepic.oss-cn-beijing.aliyuncs.com/img/c_%E5%9B%9E%E6%83%B3_.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="万字长评《美少女万华镜 - 罪与罚的少女》"/></a><div class="content"><a class="title" href="/2022/02/23/Bishoujo-Mangekyo-Tsumi-to-Batsu-no-Shoujo/" title="万字长评《美少女万华镜 - 罪与罚的少女》">万字长评《美少女万华镜 - 罪与罚的少女》</a><time datetime="2022-02-23T14:22:27.000Z" title="发表于 2022-02-23 22:22:27">2022-02-23</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://ekkepic.oss-cn-beijing.aliyuncs.com/img/20210701162440.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Ekennis</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Close touch with <a target="_blank" rel="noopener" href="https://blog.zxymoe.fun/">Rsf</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/algolia.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'MMjnuRXTCG8qmRT4wCsy2fuJ-gzGzoHsz',
      appKey: 'naz1rzw8ub8HyVVeEzxw6mhO',
      placeholder: '说点儿啥QWQ（支持Markdown语法，评论将受审核！之前被垃圾评论轰炸了一次）',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="true" data-text="HELLO!" data-fontsize="12px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>